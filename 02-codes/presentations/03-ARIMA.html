<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>03-ARIMA</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="03-ARIMA_files/libs/clipboard/clipboard.min.js"></script>
<script src="03-ARIMA_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="03-ARIMA_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="03-ARIMA_files/libs/quarto-html/popper.min.js"></script>
<script src="03-ARIMA_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="03-ARIMA_files/libs/quarto-html/anchor.min.js"></script>
<link href="03-ARIMA_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="03-ARIMA_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="03-ARIMA_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="03-ARIMA_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="03-ARIMA_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">03-ARIMA</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="cours" class="level1">
<h1>Cours</h1>
<p>Une série temporelle est une suite de variables aléatoires indexée par le temps. Un tel processus est aussi appelé processus stochastique. Lorsque l’on collecte un échantillon de données temporelles, on obtient un résultat possible, ou une réalisation, d’un processus stochastique. Cette réalisation est unique car on ne peut pas revenir en arrière et recommencer le processus à nouveau. Toutefois, si certaines conditions dans l’histoire avaient été différentes, on aurait généralement obtenu une réalisation différente.</p>
<p>Les séries temporelles sont souvent auto-corrélées dans le temps, entraînant ainsi le besoin d’ajuster les modélisations déjà vues. S’il est possible comme en coupe instantanée de faire des modèles statiques tels que :</p>
<p><span class="math display">\[
Y_t = \alpha + \beta_1 X_t + u_t
\]</span></p>
<p>où la variable endogène à l’instant <span class="math inline">\(t\)</span> dépend de la valeur de la variable exogène à l’instant <span class="math inline">\(t\)</span>, la possible présence d’auto-corrélation nécessite d’ajuster les modèles pour prendre en compte les périodes passées.</p>
<p>Dans ce chapitre nous allons uniquement modéliser une série <span class="math inline">\(Y_t\)</span> par ses valeurs passées (aussi appelés <em>lags</em> ou <em>retards</em>) et pas des chocs aléatoires.</p>
<section id="stationnarité" class="level2">
<h2 class="anchored" data-anchor-id="stationnarité">Stationnarité</h2>
<p>Les séries temporelles et financières sont très souvent caractérisées par un non-stationnarité en moyenne et/ou en variance. Une série est dite non stationnaire si ses propriétés statistiques changent au cours du temps. Plus formellement, on dira qu’une série est stationnaire au second ordre si :</p>
<p><span class="math display">\[
\begin{align}
E(X_t^2) &amp;&lt; \infty \\
E(X_t) &amp;= m \hspace{0.3cm} \forall \hspace{0.3cm} t \\
E(X_t,X_{t+h}) &amp;= \gamma_h \hspace{0.3cm} \forall \hspace{0.3cm} t, \hspace{0.3cm} \forall \hspace{0.3cm} h
\end{align}
\]</span></p>
<p>Une série stationnaire au second ordre doit avoir une variance finie, une moyenne constante au cours du temps et son auto-covariance doit dépendre uniquement de la différence des temps <span class="math inline">\(h\)</span>.</p>
<p>La non-stationnarité a des conséquences fortes au niveau économétriques. Les méthodes habituelles ne sont plus valables puisque les estimateurs ne sont plus convergents, ils convergent vers une variable aléatoire et non plus leur vraie valeur. Egalement, les distribution asymptotiques ne sont plus standards.</p>
<p>De plus, si l’on régresse une série non stationnaire sur une autre série non-stationnaire, on obtient (sauf cointégration) une régression fallacieuse, c’est à dire que l’on va croire à un pouvoir explicatif de la variable exogène, alors qu’en réalité la corrélation est simplement due au temps qui passe. Voir le site <a href="#0">spurious-correlations</a> pour des exemples de corrélations fallacieuses.</p>
<p>Si une série est non-stationnaire, il est nécessaire de procéder à des ajustements afin de la rendre stationnaire et retrouver les bonnes propriétés des estimateurs (ou alors il faut utiliser des méthodes économétriques plus complexes qui prennent directement en compte cette non-stationnarité). Les techniques de stationnarisation vont dépendre du type de processus que suit la série temporelle :</p>
<ul>
<li><p>Processus <strong>Trend Stationnary (TS)</strong> : Dans un processus TS, les conséquences d’un choc sont transitoires, la série revient à sa valeur pré-choc (étant donné le passage du temps). La non-stationnarité est déterministe. Pour stationnariser ce type de processus, il faut retirer la tendance de la série.</p></li>
<li><p>Processus <strong>Difference Stationnary (DS)</strong> : Dans un processus DS, les conséquences d’un choc sont permanentes. La série ne revient jamais à sa valeur pré-choc. La non-stationnarité est stochastique. Pour stationnariser une telle série, on applique un filtre aux différences. Généralement on va utiliser la différence-première.</p></li>
</ul>
<p><img src="images/processus-ts-ds.png" class="img-fluid"></p>
<p>De multiples tests existent pour détecter la stationnarité tels que le test augmenté de Dickey-Fuller (ADF) ou de Phillips-Perron.</p>
</section>
<section id="auto-corrélation-et-auto-corrélation-partielle" class="level2">
<h2 class="anchored" data-anchor-id="auto-corrélation-et-auto-corrélation-partielle">Auto-corrélation et auto-corrélation partielle</h2>
<p>La fonction d’auto-corrélation (ACF) d’une série mesure la corrélation entre <span class="math inline">\(X_t\)</span> et <span class="math inline">\(X_{x+k}\)</span> où <span class="math inline">\(k\)</span> est le nombre de périodes dans le futur. Cette fonction mesure la corrélation entre deux points étant donné un intervalle de temps donné.</p>
<p>La fonction d’auto-corrélation partielle (PACF) mesure la corrélation entre <span class="math inline">\(X_t\)</span> et <span class="math inline">\(X_{t+k}\)</span> après que la corrélation entre les retards intermédiaires ait été supprimé. Autrement dit, elle mesure la corrélation directe entre deux observations temporelles.</p>
</section>
<section id="processus-bruit-blanc-bb" class="level2">
<h2 class="anchored" data-anchor-id="processus-bruit-blanc-bb">Processus bruit blanc (BB)</h2>
<p>Une série temporelle <span class="math inline">\(Y_t\)</span> est appelée <strong>bruit blanc</strong> si :</p>
<p><span class="math display">\[
\begin{align}
Y_t &amp;= \varepsilon_t \\
E(\varepsilon_t) &amp;= 0 \hspace{0.3cm} \forall \hspace{0.3cm} t \\
V(\varepsilon_t) &amp;= \sigma_\varepsilon^2 \hspace{0.3cm} \forall \hspace{0.3cm} t \\
Cov(\varepsilon_t, \varepsilon_{t'}) &amp;= 0 \hspace{0.3cm} \forall \hspace{0.3cm} t \neq t'
\end{align}
\]</span></p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Un bruit blanc est donc un processus de moyenne nulle, de variance constante et non auto-corrélé. Un bruit ne suit pas forcément une loi normale.</p>
</section>
<section id="marche-aléatoire" class="level2">
<h2 class="anchored" data-anchor-id="marche-aléatoire">Marche Aléatoire</h2>
<p>Une série est appelée marche aléatoire (Random Walk) si :</p>
<p><span class="math display">\[
Y_t =  Y_{t-1} + \varepsilon_t
\]</span></p>
<p>Avec <span class="math inline">\(\varepsilon_t \sim (0, \sigma_\varepsilon^2)\)</span>. Il s’agit d’un processus non-stationnaire dans lequel la valeur en <span class="math inline">\(t\)</span> de la série est définie entièrement par sa valeur en <span class="math inline">\(t-1\)</span> et une variation aléatoire. Une marche aléatoire est par définition imprévisible.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="processus-auto-régressif-ar" class="level2">
<h2 class="anchored" data-anchor-id="processus-auto-régressif-ar">Processus Auto-Régressif (AR)</h2>
<p>On appelle processus auto-régressif d’ordre <span class="math inline">\(p\)</span> noté <span class="math inline">\(AR(p)\)</span>, un processus <span class="math inline">\(Y_t\)</span> stationnaire tel que :</p>
<p><span class="math display">\[
Y_t = - \phi_1Y_{t-1} - \cdots - \phi_p Y_{t-p} = \varepsilon_t
\]</span></p>
<p>Avec <span class="math inline">\(\phi_i \in R, i = 1, \cdots, p\)</span> et <span class="math inline">\(\varepsilon_t \sim BB(0, \sigma{\varepsilon}^2)\)</span>.</p>
<p>En introduisant l’opérateur retard, on peut écrire :</p>
<p><span class="math display">\[
\left( 1 - \phi_1 L - \phi_p L^p \right) Y_t = \varepsilon_t
\]</span></p>
<p>Ou encore sous forme compacte :</p>
<p><span class="math display">\[
\Phi \left( L \right) Y_t = \varepsilon_t
\]</span></p>
<p>Pour un <span class="math inline">\(AR(p)\)</span>, les auto-corrélations partielles s’annulent à partir du rang <span class="math inline">\(p+1\)</span>. Cette propriété peut être utilisée pour définir graphiquement l’ordre d’un processus <span class="math inline">\(AR(p)\)</span>. La fonction d’auto-corrélation n’a pas de forme définie.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Don't know how to automatically pick scale for object of type &lt;ts&gt;. Defaulting
to continuous.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="processus-moyenne-mobile-ma" class="level2">
<h2 class="anchored" data-anchor-id="processus-moyenne-mobile-ma">Processus Moyenne Mobile (MA)</h2>
<p>On appelle processus <span class="math inline">\(MA(q)\)</span> un processus <span class="math inline">\(Y_t\)</span> stationnaire tel que :</p>
<p><span class="math display">\[
Y_t = \varepsilon_t - \theta_1 \varepsilon_{t-1} - \cdots - \theta_q \varepsilon_{t-q}
\]</span></p>
<p>Avec : <span class="math inline">\(\theta_i \in R, i=1, \cdots, q\)</span> et <span class="math inline">\(\varepsilon_t \sim BB \left(0, \sigma_{\varepsilon}^2 \right)\)</span></p>
<p>Avec l’opérateur retard, on a :</p>
<p><span class="math display">\[
Y_t = \left( 1 - \theta_1 L - \cdots - \theta_q L^q \right)\varepsilon_t
\]</span></p>
<p>ou encore :</p>
<p><span class="math display">\[
Y_t = \Theta \left( L \right)\varepsilon_t
\]</span></p>
<p>Pour un processus <span class="math inline">\(MA(q)\)</span>, la fonction d’auto-corrélation s’annule à partir du rang <span class="math inline">\(q+1\)</span>. La fonction d’auto-corrélation partielle n’a pas de forme définie.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Don't know how to automatically pick scale for object of type &lt;ts&gt;. Defaulting
to continuous.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="inversion-des-processus" class="level2">
<h2 class="anchored" data-anchor-id="inversion-des-processus">Inversion des processus</h2>
<p>Si le polynome <span class="math inline">\(\Theta (L)\)</span> est inversible, on peut écrire un processus <span class="math inline">\(MA(q)\)</span> sous la forme d’un <span class="math inline">\(AR(\infty)\)</span> :</p>
<p><span class="math display">\[ \varepsilon_t = \Theta^{-1} \left( L \right)Y_t = \sum_{i=0}^{\infty} \beta_i Y_{t-i} \]</span></p>
<p>Avec <span class="math inline">\(\beta_0 = 1\)</span> et <span class="math inline">\(\sum \left| \beta_i \right| &lt; \infty\)</span>.</p>
<p>Si le polynome <span class="math inline">\(\Phi(L)\)</span> est inversible, on peut écrire un processus <span class="math inline">\(AR(p)\)</span> sous forme <span class="math inline">\(MA(\infty)\)</span> :</p>
<p><span class="math display">\[ X_t = \Phi^{-1} \left( L \right) \varepsilon_t = \sum_{i=0}^{\infty} \alpha_i\varepsilon_{t-i} \]</span></p>
<p>Avec <span class="math inline">\(\alpha_0 = 1\)</span> et <span class="math inline">\(\sum \left| \alpha_i \right| &lt; \infty\)</span>.</p>
</section>
<section id="processus-armapq" class="level2">
<h2 class="anchored" data-anchor-id="processus-armapq">Processus ARMA(p,q)</h2>
<p>Les processus <span class="math inline">\(ARMA(p,q)\)</span> permettent d’avoir une structure plus parcimonieuse des retards par rapport à un processus <span class="math inline">\(AR(p)\)</span> ou <span class="math inline">\(MA(q)\)</span>.</p>
<p>Un processus <span class="math inline">\(Y_t\)</span> stationnaire suit un processus <span class="math inline">\(ARMA(p,q)\)</span> si :</p>
<p><span class="math display">\[
Y_t - \phi_1 Y_{t-1} - \cdots - \phi_p Y_{t-p} = \varepsilon_t - \theta_1 \varepsilon_{t-1} - \cdots - \phi_q \varepsilon_{t-q}
\]</span></p>
<p>Avec : <span class="math inline">\(\phi_i \in R, i=1, \cdots, q\)</span> , <span class="math inline">\(\theta_i \in R, i=1, \cdots, q\)</span> et <span class="math inline">\(\varepsilon_t \sim BB \left(0, \sigma_{\varepsilon}^2 \right)\)</span></p>
<p>En introduisant l’opérateur retard, on a :</p>
<p><span class="math display">\[
\left( 1 - \phi_1L - \cdots - \phi_p L^{p} \right)Y_t = \left( 1 - \theta_1 L - \cdots - \theta_qL^q \right)\varepsilon_t
\]</span></p>
<p>Ou encore :</p>
<p><span class="math display">\[
\Phi \left( L \right) Y_t = \Theta \left( L \right)\varepsilon_t
\]</span></p>
<p>On peut déterminer graphiquement l’ordre d’un processus <span class="math inline">\(ARMA(p,q)\)</span> en regardant les ACF et PACF et en utilisant les mêmes règles que pour les processus <span class="math inline">\(AR\)</span> et <span class="math inline">\(MA\)</span>.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Don't know how to automatically pick scale for object of type &lt;ts&gt;. Defaulting
to continuous.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="processus-sarmapqpq" class="level2">
<h2 class="anchored" data-anchor-id="processus-sarmapqpq">Processus SARMA(p,q)(P,Q)</h2>
<p>Lorsqu’une série présente de la saisonnalité, 2 grandes possibilités existent pour la prendre en compte dans notre modélisation :</p>
<ul>
<li><p>corriger les séries des variations saisonnières</p></li>
<li><p>Modélisation la saisonnalité au moyen d’un processus SARMA</p></li>
</ul>
<p>Un processus <span class="math inline">\(SARMA(p,q)(P,Q)\)</span> s’écrit :</p>
<p><span class="math display">\[
\left( 1 - a\phi_1L - \cdots - \phi_pL^p \right) \left( 1 - \phi_{1S}L_S - \cdots - \phi_{PS}L^P_S \right)Y_t = \left( 1 - \theta_1 L - \cdots - \theta_qL^q \right) \left( 1 - \theta_{1S} L_S - \cdots - \theta_{QS}L^Q_S \right)\varepsilon_t
\]</span></p>
<p>S’il existe différent type de saisonnalité, on utilise un polynôme saisonnier par saisonnalité.</p>
</section>
<section id="processus-arimapdq" class="level2">
<h2 class="anchored" data-anchor-id="processus-arimapdq">Processus ARIMA(p,d,q)</h2>
<p>Si une série <span class="math inline">\(Y_t\)</span> est non stationnaire, cette non-stationnarité peut être estimée au moyen d’un processus <span class="math inline">\(ARMA(p,q)\)</span> intégré noté <span class="math inline">\(ARIMA(p,d,q)\)</span> ou <span class="math inline">\(d\)</span> est un nombre entier et est le paramètre d’intégration. Il s’agit du nombre de fois qu’il faut différencier une série pour la rendre stationnaire.</p>
<p>Un processus <span class="math inline">\(ARIMA(p,d,q)\)</span> s’écrit :</p>
<p><span class="math display">\[
\Phi \left( L \right) \left( 1-L \right)^d Y_t = \Theta \left( L \right)\varepsilon_t
\]</span></p>
<p>Estimer un processus <span class="math inline">\(ARIMA(p,d,q)\)</span> sur <span class="math inline">\(Y_t\)</span> revient à estimer un <span class="math inline">\(ARMA(p,q)\)</span> sur <span class="math inline">\(\Delta^d Y_t\)</span>.</p>
<p>Rappel que : <span class="math inline">\(\left( 1 - L^2 \right)Y_t =  \left( 1 - 2L + L^2 \right)Y_t\)</span></p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Don't know how to automatically pick scale for object of type &lt;ts&gt;. Defaulting
to continuous.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="processus-arfimapdq" class="level2">
<h2 class="anchored" data-anchor-id="processus-arfimapdq">Processus ARFIMA(p,d,q)</h2>
<p>Un processus <span class="math inline">\(ARFIMA(p,d,q)\)</span> est un procesus fractionnairement intégré. Il s’écrit :</p>
<p><span class="math display">\[
\Phi \left( L \right) \left( 1-L \right)^d Y_t = \Theta \left( L \right)\varepsilon_t
\]</span></p>
<p>Avec <span class="math inline">\(d\)</span> un nombre réel fractionnaire. Un tel processus permet de modéliser les séries très persistantes à mémoire longue.</p>
</section>
<section id="identification-dun-processus-armapq" class="level2">
<h2 class="anchored" data-anchor-id="identification-dun-processus-armapq">Identification d’un processus ARMA(p,q)</h2>
<p>Avant de modéliser notre série et d’estimer le processus choisi, il faut d’abord identifier le processus que suit la série.</p>
<section id="déterminer-lordre-maq" class="level3">
<h3 class="anchored" data-anchor-id="déterminer-lordre-maq">Déterminer l’ordre MA(q)</h3>
<p>Pour déterminer l’ordre <span class="math inline">\(q\)</span> d’un processus <span class="math inline">\(ARMA(p,q)\)</span>, on commence par calculer la fonction d’auto-corrélation de la série <span class="math inline">\(Y_t\)</span> :</p>
<p><span class="math display">\[
\hat{\rho}_k = \frac{\frac{1}{T} \sum_{t=1}^{T-k} \left( Y_t - \bar{Y} \right) \left( Y_{t+k} - \bar{Y} \right)}{\frac{1}{T} \sum_{t=1}^T \left( Y_t - \bar{Y} \right)^2}
\]</span></p>
<p>Avec <span class="math inline">\(k = 1, 2, \cdots, K\)</span>. Box et Jenkins recommandent de choisir <span class="math inline">\(K = \frac{T}{4}\)</span>.</p>
<p><span class="math display">\[
\begin{cases}
H_0 : \hat{\rho}_k = 0 \\
H_1 : \hat{\rho}_k \neq 0
\end{cases}
\]</span></p>
<p>avec sous <span class="math inline">\(H_0\)</span> : <span class="math inline">\(\hat{\rho}_k \sim N(0, \sigma_\rho^2)\)</span>.</p>
<p>La règle de décision est classique :</p>
<ul>
<li><p>Si <span class="math inline">\(|t_{\hat{\rho}_k}| \geq 1.96\)</span> (ou <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette l’hypothèse nulle. L’auto-corrélation d’ordre <span class="math inline">\(k\)</span> est significativement différente de 0.</p></li>
<li><p>Si <span class="math inline">\(|t_{\hat{\rho}_k}| &lt; 1.96\)</span> (ou <span class="math inline">\(p.value &gt; 0.05\)</span>), on ne peut pas rejeter l’hypothèse nulle. L’auto-corrélation d’ordre <span class="math inline">\(k\)</span> n’est pas significativement différente de 0.</p></li>
</ul>
<p>L’ordre du processus <span class="math inline">\(MA\)</span> est donné lorsque l’on ne peut plus rejeter l’hypothèse nulle.</p>
</section>
<section id="déterminer-lordre-arp" class="level3">
<h3 class="anchored" data-anchor-id="déterminer-lordre-arp">Déterminer l’ordre AR(p)</h3>
<p>Pour déterminer l’ordre <span class="math inline">\(p\)</span> d’un processus <span class="math inline">\(ARMA(p,q)\)</span>, on calcule la fonction d’auto-corrélation partielle avec l’aide de l’algorithme de Durbin.</p>
<p>On teste :</p>
<p><span class="math display">\[
\begin{cases}
H_0 : \phi_{kk} = 0 \\
H_1 : \phi_{kk} \neq 0
\end{cases}
\]</span></p>
<p>Avec sous <span class="math inline">\(H_0\)</span> : <span class="math inline">\(\phi_{kk} \sim N(0, \sigma_{\phi_{kk}}^2)\)</span>.</p>
<p>La règle de décision est classique :</p>
<ul>
<li><p>Si <span class="math inline">\(|t_{\hat{\phi}_{kk}}| \geq 1.96\)</span> (ou <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette l’hypothèse nulle. L’auto-corrélation partielle d’ordre <span class="math inline">\(k\)</span> est significativement différente de 0.</p></li>
<li><p>Si <span class="math inline">\(|t_{\hat{\phi}_{kk}}| &lt; 1.96\)</span> (ou <span class="math inline">\(p.value &gt; 0.05\)</span>), on ne peut pas rejeter l’hypothèse nulle. L’auto-corrélation partielle d’ordre <span class="math inline">\(k\)</span> n’est pas significativement différente de 0.</p></li>
</ul>
</section>
<section id="modèles-identifiés" class="level3">
<h3 class="anchored" data-anchor-id="modèles-identifiés">Modèles identifiés</h3>
<p>Les deux étapes précédentes nous ont permis d’identifier un ou plusieurs modèles possibles. Si un ordre <span class="math inline">\(p = 3\)</span> a été trouvé, cela signifie que les modèles <span class="math inline">\(AR(p)\)</span> possibles sont : <span class="math inline">\(AR(1)\)</span>, <span class="math inline">\(AR(2)\)</span> et <span class="math inline">\(AR(3)\)</span>. Si un ordre <span class="math inline">\(q=2\)</span> a été trouvé, cela signifie que les modèles <span class="math inline">\(MA(q)\)</span> possibles sont : <span class="math inline">\(MA(1)\)</span> et <span class="math inline">\(MA(2)\)</span>.</p>
<p>Les processus <span class="math inline">\(ARMA(p,q)\)</span> possible correspondent à toutes les combinaisons possibles de ces différents processus.</p>
</section>
</section>
<section id="estimation-des-processus-arma" class="level2">
<h2 class="anchored" data-anchor-id="estimation-des-processus-arma">Estimation des processus ARMA</h2>
<p>Pour estimer un processus <span class="math inline">\(ARMA(p,q)\)</span>, on utilise la méthode du maximum de vraisemblance. Cette méthode consiste à maximiser la log-vraisemblance d’un modèle afin que les valeurs prédites soient le plus proche possible des vraies valeurs de la série. On suppose généralement que <span class="math inline">\(\varepsilon_t \sim N(0, \sigma_\varepsilon^2)\)</span>.</p>
<p>La log-vraisemblance d’un modèle <span class="math inline">\(ARMA(p,q)\)</span> s’écrit :</p>
<p><span class="math display">\[
log(L_t) = - \frac{T}{2} log(2 \pi) - \frac{T}{2} log(\sigma_{\varepsilon}^2) - \frac{T}{2} log \left( \text{det}(ZZ' ) \right) - \frac{S(\phi, \theta)}{2 \sigma_{\varepsilon}^2}
\]</span></p>
<p>Avec <span class="math inline">\(Z\)</span> une matrice dépendant des paramètres <span class="math inline">\(\phi\)</span> et <span class="math inline">\(\theta\)</span> et</p>
<p><span class="math display">\[
S(\phi, \theta) = \sum \left( E \left[ \varepsilon_t | X_t, \phi_i, \theta_j, \sigma_{\varepsilon}^2 \right] \right)^2
\]</span></p>
<p>On cherche à maximiser <span class="math inline">\(Log(L_t)\)</span> par rapport à : <span class="math inline">\(\phi_i, \theta_j, \sigma_{\varepsilon}^2\)</span>.</p>
<p>Le but de cette étape est d’estimer les paramètres <span class="math inline">\(\phi_i\)</span> et <span class="math inline">\(\theta_j\)</span> pour l’ensemble des modèles identifiés.</p>
</section>
<section id="validation-des-processus-arma" class="level2">
<h2 class="anchored" data-anchor-id="validation-des-processus-arma">Validation des processus ARMA</h2>
<p>Cette étape consiste à valider les modèles estimés, puis à les départager. Pour cela, on va appliquer un certain nombre de tests sur les résidus afin de déterminer s’ils suivent bien un bruit blanc. Sinon cela veut dire que des caractéristiques de la série n’ont pas été prises en compte dans la modélisation.</p>
<p>On va également appliquer des tests de significativité sur les paramètres afin de garder les modèles avec des paramètres significatifs.</p>
<p>Enfin, on va départager les modèles ayant passé les différents tests en utilisant les critères de sélection.</p>
<section id="tests-sur-les-paramètres" class="level3">
<h3 class="anchored" data-anchor-id="tests-sur-les-paramètres">Tests sur les paramètres</h3>
<p>Le but ici est de tester si les derniers retards inclus sont significativement différents de 0 ou non. Si ce n’est pas le cas, leur inclusion n’est guère utile et on va privilégié un modèle plus parcimonieux.</p>
<p>On peut donc tester <span class="math inline">\(H_0 : p' = p-1, q' = q\)</span></p>
<p><span class="math display">\[
\begin{cases}
H_0 : \text{ARMA}(p-1, q) &amp;\Leftrightarrow \phi_p = 0 \\
H_1 : \text{ARMA}(p,q)&amp; \Leftrightarrow \phi_p \neq 0
\end{cases}
\]</span></p>
<p>La règle de décision est classique :</p>
<ul>
<li><p>Si <span class="math inline">\(|t_{\hat{\phi}_p}| \geq 1.96\)</span> (ou <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette l’hypothèse nulle de non significativité du coefficient. On valide donc l’inclusion du <span class="math inline">\(p^{\text{ième}}\)</span> coefficient.</p></li>
<li><p>Si <span class="math inline">\(|t_{\hat{\phi}_p}| &lt; 1.96\)</span> (ou <span class="math inline">\(p.value &gt;0.05\)</span>), on ne peut pas rejeter l’hypothèse nulle de non significativité du coefficient. On ne valide donc pas l’inclusion du <span class="math inline">\(p^{\text{ième}}\)</span> coefficient. Il faut donc estimer puis tester un <span class="math inline">\(ARMA(p-1,q)\)</span>.</p></li>
</ul>
<p>On effectue le même test sur le coefficient <span class="math inline">\(q\)</span> :</p>
<p>On peut donc tester <span class="math inline">\(H_0 : p' = p, q' = q-1\)</span></p>
<p><span class="math display">\[ \begin{cases} H_0 : \text{ARMA}(p, q-1) &amp;\Leftrightarrow \theta_q = 0 \\ H_1 : \text{ARMA}(p,q)&amp; \Leftrightarrow \theta_q \neq 0 \end{cases} \]</span></p>
<p>La règle de décision est classique :</p>
<ul>
<li><p>Si <span class="math inline">\(|t_{\hat{\theta}_q}| \geq 1.96\)</span> (ou <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette l’hypothèse nulle de non significativité du coefficient. On valide donc l’inclusion du <span class="math inline">\(q^{\text{ième}}\)</span> coefficient.</p></li>
<li><p>Si <span class="math inline">\(|t_{\hat{\theta}_q}| &lt; 1.96\)</span> (ou <span class="math inline">\(p.value &gt;0.05\)</span>), on ne peut pas rejeter l’hypothèse nulle de non significativité du coefficient. On ne valide donc pas l’inclusion du <span class="math inline">\(q^{\text{ième}}\)</span> coefficient. Il faut donc estimer puis tester un <span class="math inline">\(ARMA(p,q-1)\)</span>.</p></li>
</ul>
<p>Le but ici est d’éliminer l’ensemble des modèles dont les derniers retards ne sont pas significatifs.</p>
</section>
<section id="tests-sur-les-résidus" class="level3">
<h3 class="anchored" data-anchor-id="tests-sur-les-résidus">Tests sur les résidus</h3>
<section id="absence-dauto-corrélation" class="level4">
<h4 class="anchored" data-anchor-id="absence-dauto-corrélation">Absence d’auto-corrélation</h4>
<p>Les tests d’auto-corrélation servent à déterminer si toute la dynamique de la série a bien été prise en compte ou pas. Les résidus ne doivent pas être auto-corrélé, sinon cela signifie qu’une partie de la dynamique a été mise de coté.</p>
<p>Les tests les plus utilisés sont les tests de Box-Pierce et de Ljung-Box</p>
<section id="test-de-box-pierce" class="level5">
<h5 class="anchored" data-anchor-id="test-de-box-pierce">Test de Box-Pierce</h5>
<p>On teste l’hypothèse nulle d’absence d’auto-corrélation dans les résidus.</p>
<p><span class="math display">\[
\begin{cases}
H_0 : \hat{\rho}_{\hat{\varepsilon}1} = \cdots = \hat{\rho}_{\hat{\varepsilon}K} \\
H_1 : \exists \hat{\rho}_{\hat{\varepsilon}k} \neq 0
\end{cases}
\]</span></p>
<p>Une fois le modèle estimé, on récupère donc la série des résidus et on calcule la statistique de test :</p>
<p><span class="math display">\[
BP(K) = T \sum_{k=1}^K \hat{\rho}_{\hat{\varepsilon}k} \sim \chi^2(K-p-q)
\]</span></p>
<p>Avec <span class="math inline">\(\hat{\rho}_{\hat{\varepsilon}k}\)</span> le coefficient d’auto-corrélation des résidus à l’ordre <span class="math inline">\(k\)</span>.</p>
<p>La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(BP(K) \geq \chi^2(K-p-q)\)</span> (ou si <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette <span class="math inline">\(H_0\)</span>. Les résidus sont auto-corrélés à l’ordre <span class="math inline">\(k\)</span>. Le modèle n’est pas validé. Toute la dynamique de la série n’est pas identifiée.</p></li>
<li><p>Si <span class="math inline">\(BP(K) &lt; \chi^2(K-p-q)\)</span> (ou si <span class="math inline">\(p.value &gt; 0.05\)</span>), on ne peut pas rejeter <span class="math inline">\(H_0\)</span>. Les résidus ne sont pas auto-corrélés à l’ordre <span class="math inline">\(k\)</span>. Le modèle est validé de ce point de vue. Toute la dynamique de la série semble identifiée.</p></li>
</ul>
</section>
<section id="test-de-ljung-box" class="level5">
<h5 class="anchored" data-anchor-id="test-de-ljung-box">Test de Ljung-Box</h5>
<p>Ce test est à privilégier dans le cadre de petits échantillons.</p>
<p>On teste l’hypothèse nulle d’absence d’auto-corrélation dans les résidus :</p>
<p><span class="math display">\[
\begin{cases}
H_0 : \hat{\rho}_{\hat{\varepsilon}1} = \cdots = \hat{\rho}_{\hat{\varepsilon}K} \\
H_1 : \exists \hat{\rho}_{\hat{\varepsilon}k} \neq 0
\end{cases}
\]</span></p>
<p>Une fois le modèle estimé, on récupère donc la série des résidus et on calcule la statistique de test :</p>
<p><span class="math display">\[
LB(K) = T(T+2) \sum_{k=1}^K \frac{\hat{\rho}_{\hat{\varepsilon}k}^2}{T-K} \sim \chi^2(K-p-q)
\]</span></p>
<p>Avec <span class="math inline">\(\hat{\rho}_{\hat{\varepsilon}k}\)</span> le coefficient d’auto-corrélation des résidus à l’ordre <span class="math inline">\(k\)</span>.</p>
<p>La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(LB(K) \geq \chi^2(K-p-q)\)</span> (ou si <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette <span class="math inline">\(H_0\)</span>. Les résidus sont auto-corrélés à l’ordre <span class="math inline">\(k\)</span>. Le modèle n’est pas validé. Toute la dynamique de la série n’est pas identifiée.</p></li>
<li><p>Si <span class="math inline">\(LB(K) &lt; \chi^2(K-p-q)\)</span> (ou si <span class="math inline">\(p.value &gt; 0.05\)</span>), on ne peut pas rejeter <span class="math inline">\(H_0\)</span>. Les résidus ne sont pas auto-corrélés à l’ordre <span class="math inline">\(k\)</span>. Le modèle est validé de ce point de vue. Toute la dynamique de la série semble identifiée.</p></li>
</ul>
</section>
</section>
<section id="homoscédasticité" class="level4">
<h4 class="anchored" data-anchor-id="homoscédasticité">Homoscédasticité</h4>
<p>La variance des résidus doit être constante. Sinon cela signifie que des éléments de la dynamique n’ont ps été pris en compte.</p>
<section id="test-de-white" class="level5">
<h5 class="anchored" data-anchor-id="test-de-white">Test de White</h5>
<p>On récupère la série des résidus <span class="math inline">\(\hat{\varepsilon}_t\)</span> du modèle.</p>
<p>On estime une régression du type :</p>
<p><span class="math display">\[
\hat{\varepsilon}_t^2 = a_0 + a_1 Y_{t-1} + b_1 Y_{t-1}^2 + \cdots + a_p Y_{t-p} + b_p Y_{t-p}^2 + u_t
\]</span></p>
<p>On test l’hypothèse nulle de variance constante (homoscédasticité) :</p>
<p><span class="math display">\[
\begin{cases}  H_0 : a_i = b_i = 0 \hspace{0.3cm} \forall i = 1, \cdots, p \\  H_1 : \exists \hspace{0.3cm} a_i \neq 0 \hspace{0.3cm} | \hspace{0.3cm} b_i \neq 0\end{cases}
\]</span></p>
<p>On calcule la statistique de test :</p>
<p><span class="math display">\[
LM = TR^2 \sim \chi^2(2p)
\]</span></p>
<p>Avec <span class="math inline">\(R^2\)</span> le coefficient de détermination de la régression auxiliaire estimée.</p>
<p>La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(LM \geq \chi^2(2p)\)</span> (ou <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette <span class="math inline">\(H_0\)</span>. Les résidus n’ont pas une variance constante et sont donc hétéroscédastiques. Toute la dynamique de la série n’a pas été prise en compte. Le modèle est invalidé.</p></li>
<li><p>Si <span class="math inline">\(LM &lt; \chi^2(2p)\)</span> (ou <span class="math inline">\(p.value &gt;0.05\)</span>), on ne peut pas rejeter <span class="math inline">\(H_0\)</span>. Les résidus ont une variance constante et sont donc homoscédastiques. Toute la dynamique de la série semble prise en compte. Le modèle est validé de ce point de vue.</p></li>
</ul>
</section>
<section id="test-arch" class="level5">
<h5 class="anchored" data-anchor-id="test-arch">Test ARCH</h5>
<p>Le test ARCH vise à déterminer si la série suit un processus Autoregressif Conditionnellement Hétéroscédastique (ARCH). Un tel processus est caractérisé par une variance non-constante au cours du temps et dont la dynamique (de la variance) dépend de ses propres valeurs passées. Cela amène à des phénomènes de <em>cluster</em> de volatilité très courants avec des séries financières.</p>
<p>On estime le modèle, puis l’on récupère la série des résidus <span class="math inline">\(\hat{\varepsilon}_t\)</span>.</p>
<p>On estime la régression suivante :</p>
<p><span class="math display">\[
\hat{\varepsilon}_t^2 = \alpha_0 + \sum_{i=1}^l \alpha_i \hat{\varepsilon}_{t-i}^2
\]</span></p>
<p>On calcule ensuite le coefficient de détermination <span class="math inline">\(R^2\)</span> de cette régression.</p>
<p>On teste l’hypothèse nulle d’absence d’hétéroscédasticité conditionnelle :</p>
<p><span class="math display">\[
\begin{cases}  
H_0 : \alpha_i = 0 \hspace{0.3cm} \forall i = 1, \cdots, l \\  
H_1 : \exists \alpha_i \neq 0
\end{cases}
\]</span></p>
<p>On calcule la statistique :</p>
<p><span class="math display">\[
LM = TR^2 \sim \chi^2(l)
\]</span></p>
<p>La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(LM \geq \chi^2(l)\)</span> (ou <span class="math inline">\(p.value \leq 0.05\)</span>), on rejette <span class="math inline">\(H_0\)</span>. Les résidus n’ont pas une variance conditionnelle constante et sont donc conditionnellement hétéroscédastiques. Toute la dynamique de la série n’a pas été prise en compte. Le modèle est invalidé.</p></li>
<li><p>Si <span class="math inline">\(LM &lt; \chi^2(2p)\)</span> (ou <span class="math inline">\(p.value &gt;0.05\)</span>), on ne peut pas rejeter <span class="math inline">\(H_0\)</span>. Les résidus ont une variance conditionnelle constante et sont donc conditionnellement homoscédastiques. Toute la dynamique de la série semble prise en compte. Le modèle est validé de ce point de vue.</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="sélection-dun-processus-arma" class="level2">
<h2 class="anchored" data-anchor-id="sélection-dun-processus-arma">Sélection d’un processus ARMA</h2>
<p>A l’issu des différents tests, il est possibles que différents modèles soient sélectionnés. Pour choisir le modèle à garder, on va utiliser des critères de choix de modèles.</p>
<section id="critères-standards" class="level3">
<h3 class="anchored" data-anchor-id="critères-standards">Critères standards</h3>
<p>Ces critères sont basés sur l’erreur de prévision des valeurs valeurs prédites <span class="math inline">\(\hat{\varepsilon}_t\)</span> que l’on va chercher à minimiser. On peut utiliser les critères suivants :</p>
<ul>
<li>Erreur Absolue Moyenne (MAE)</li>
</ul>
<p><span class="math display">\[
\text{MAE} = \frac{1}{T} \sum_t \left| \hat{\varepsilon}_t \right|
\]</span></p>
<ul>
<li>Racine de l’erreur quadratique moyenne (RMSE)</li>
</ul>
<p><span class="math display">\[
\text{RMSE} = \sqrt{\frac{1}{T} \sum_t \hat{\varepsilon}_t^2}
\]</span></p>
<ul>
<li>Écart absolu Moyen en % (MAPE)</li>
</ul>
<p><span class="math display">\[
\text{MAPE} = 100 \times \frac{1}{T} \sum_t \left| \frac{\hat{\varepsilon}_t}{Y_t} \right|
\]</span></p>
</section>
<section id="les-critères-dinformation" class="level3">
<h3 class="anchored" data-anchor-id="les-critères-dinformation">Les critères d’information</h3>
<p>Les critères d’information opèrent un arbitrage entre la bonne qualité d’ajustement du modèle et la parcimonie du modèle. Ces critères sont à minimiser et vont indiquer le modèle qui sera le plus parcimonieux possible tout en gardant une bonne qualité de prédiction.</p>
<ul>
<li>Akaike (AIC)</li>
</ul>
<p><span class="math display">\[
\text{AIC} = log \left( \hat{\sigma}_{\varepsilon}^2 \right) + \frac{2(p+q)}{T}
\]</span></p>
<ul>
<li>Schwarz (SIC)</li>
</ul>
<p><span class="math display">\[
\text{SIC} = log \left( \hat{\sigma}_{\varepsilon}^2 \right) + (p+q) \frac{log(T)}{T}
\]</span></p>
<ul>
<li>Hanan-Quinn (HQ)</li>
</ul>
<p><span class="math display">\[
\text{HQ} = log \left( \hat{\sigma}_{\varepsilon}^2 \right) + \alpha (p+q) log \left( \frac{log(T)}{T} \right)
\]</span></p>
<p>avec <span class="math inline">\(\alpha\)</span> une constante que l’on choisit avec généralement <span class="math inline">\(\alpha = 1\)</span>.</p>
<p>Généralement, le critère SIC aura tendance à retenir des modèles plus parcimonieux que le critère AIC. AIC est souvent le critère le plus utilisé.</p>
<p>On va chercher le modèle qui va minimiser le plus de critères d’informations possibles.</p>
</section>
</section>
<section id="prévisions-dun-processus-arma" class="level2">
<h2 class="anchored" data-anchor-id="prévisions-dun-processus-arma">Prévisions d’un processus ARMA</h2>
<p>Soit un processus <span class="math inline">\(ARMA(p,q) : \Phi(L) Y_t = \Theta(L) \varepsilon_t\)</span> et soit <span class="math inline">\(\hat{Y}_{t+k}\)</span> la prévision faite en <span class="math inline">\(t\)</span> pour la date <span class="math inline">\(t+k\)</span> où <span class="math inline">\(k\)</span> est l’horizon de prévision.</p>
<p>La prévision est donnée par :</p>
<p><span class="math display">\[
\hat{Y}_{t+k} = E \left[ Y_{t+k} \hspace{0.15cm} | \hspace{0.15cm} I_t  \right]
\]</span> Où <span class="math inline">\(I_t\)</span> correspond à l’ensemble d’information disponible à la date <span class="math inline">\(t\)</span>. <span class="math inline">\(I_t\)</span> contient tout l’historique de la variable <span class="math inline">\(Y_t\)</span> et du terme d’erreur <span class="math inline">\(\varepsilon_t\)</span> jusqu’à la date <span class="math inline">\(t\)</span> incluse.</p>
</section>
</section>
<section id="code" class="level1">
<h1>Code</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécute le script setup.R pour charger tous les éléments importants</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"02-codes"</span>, <span class="st">"utils"</span>, <span class="st">"setup.R"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="données-et-analyse" class="level2">
<h2 class="anchored" data-anchor-id="données-et-analyse">Données et analyse</h2>
<section id="présentation-des-données" class="level3">
<h3 class="anchored" data-anchor-id="présentation-des-données">Présentation des données</h3>
<p>Nous allons essayer de modéliser et de prédire la série du S&amp;P 500 que l’on peut obtenir depuis 2007 grâce au package <code>pdfetch</code> qui est un package permettant de télécharger des séries de données depuis de nombreuses sources différentes. Les données sont retournées comme étant des objets <code>xts</code>. Il s’agit d’un type d’objet indiquant que la série est une série temporelle. Il est parfois nécessaires pour certaines fonctions que les séries données soient dans un format temporelle à cause de la gestion des dates.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importer les données du S&amp;P500</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>sp_500 <span class="ot">&lt;-</span> pdfetch<span class="sc">::</span><span class="fu">pdfetch_YAHOO</span>(<span class="st">"^gspc"</span>, <span class="at">fields =</span> <span class="st">"adjclose"</span>, <span class="at">from =</span> <span class="fu">as.Date</span>(<span class="st">"2007-01-03"</span>), <span class="at">to =</span> <span class="fu">as.Date</span>(<span class="st">"2026-01-10"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualiser les données</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>sp_500</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            X.gspc
2007-01-03 1416.60
2007-01-04 1418.34
2007-01-05 1409.71
2007-01-08 1412.84
2007-01-09 1412.11
2007-01-10 1414.85
2007-01-11 1423.82
2007-01-12 1430.73
2007-01-16 1431.90
2007-01-17 1430.62
       ...        
2025-12-26 6929.94
2025-12-29 6905.74
2025-12-30 6896.24
2025-12-31 6845.50
2026-01-02 6858.47
2026-01-05 6902.05
2026-01-06 6944.82
2026-01-07 6920.93
2026-01-08 6921.46
2026-01-09 6966.28</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Représenter la série du S&amp;P500</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>sp_500 <span class="sc">|&gt;</span> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Visuellement, la série ne semble pas stationnaire. Elle semble être caractérisée par une tendance à la hausse et potentiellement une variance non constante.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Auto-corrélation des prix du S&amp;P500</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>sp_500 <span class="sc">|&gt;</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">acf</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La fonction d’auto-corrélation montre une très forte persistance de l’auto-corrélation ce qui est un signe de non-stationnarité.</p>
</section>
<section id="test-adf-automatique" class="level3">
<h3 class="anchored" data-anchor-id="test-adf-automatique">Test ADF automatique</h3>
<p>On va tester la non-stationnarité avec le test ADF. J’utilise ici, une fonction d’un package fait maison qui permet de faire la procédure ADF automatiquement (à l’inverse du package <code>urca</code>) et qui permet si nécessaire de retourner un dataframe avec les résultats, ce qui peut être pratique lorsque l’on veut tester la stationnarité de plusieurs séries et récupérer les résultats dans une table.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># N'exécuter que si le package dobby est installé</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Test ADF automatique</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">adf_test_auto</span>(</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    sp_500, <span class="co"># Série à utiliser</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S&amp;P500"</span>, <span class="co"># Nom à donner à la série</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">lags =</span> <span class="dv">20</span>, <span class="co"># Nombre de lags maximum à tester</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_res =</span> <span class="cn">FALSE</span> <span class="co"># Indiquer si on veut retourner un tableau de résultat ou juste un message</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  ) </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

#################################################
# Augmented Dickey-Fuller test for S&amp;P500 serie #
#################################################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>model selected : Without drift and trend</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Lags number : 9</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : S&amp;P500 serie has at least one unit root</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>t stat : 3.36366244034386</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>✖ H0 can't be rejected for a 5% confidence. S&amp;P500 serie has at least one unit root.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
</div>
<p>La série n’est pas stationnaire selon le test ADF puisque l’on ne peut pas rejeter l’hypothèse nulle.</p>
<p>Le modèle sélectionné est le modèle sans constante ni tendance. La série du S&amp;P500 est une une série de type DS. Il faut donc la différencier.</p>
</section>
<section id="test-adf-manuel" class="level3">
<h3 class="anchored" data-anchor-id="test-adf-manuel">Test ADF manuel</h3>
<p>On peut également faire le test plus manuellement avec le package <code>urca</code> et sa fonction <code>ur.df()</code>. Il s’agit de la fonction qui est utilisée dans le package <code>dobby</code>. Simplement la fonction <code>ur.df()</code> ne donne pas de résultats de manière immédiate. Il faut regarder manuellement la significativité des termes voulus et tester chaque modèle un à un.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>urca<span class="sc">::</span><span class="fu">ur.df</span>(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">y =</span> sp_500, <span class="co"># Série à utiliser</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"trend"</span>, <span class="co"># type de modèle ADF : ici avec tendance et constante</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">lags =</span> <span class="dv">10</span>, <span class="co"># nombre de lags maximum</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">selectlags =</span> <span class="st">"AIC"</span> <span class="co"># Sélection du nombre de lag avec le critère AIC</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>() <span class="co"># Donner un résummé du résultat</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
############################################### 
# Augmented Dickey-Fuller Test Unit Root Test # 
############################################### 

Test regression trend 


Call:
lm(formula = z.diff ~ z.lag.1 + 1 + tt + z.diff.lag)

Residuals:
    Min      1Q  Median      3Q     Max 
-347.70  -10.54    1.11   12.74  432.57 

Coefficients:
              Estimate Std. Error t value    Pr(&gt;|t|)    
(Intercept) -0.6614002  0.9646979  -0.686     0.49300    
z.lag.1     -0.0007583  0.0008387  -0.904     0.36596    
tt           0.0016604  0.0009183   1.808     0.07064 .  
z.diff.lag1 -0.0741748  0.0144829  -5.122 0.000000315 ***
z.diff.lag2  0.0364566  0.0145097   2.513     0.01202 *  
z.diff.lag3 -0.0382255  0.0145122  -2.634     0.00847 ** 
z.diff.lag4 -0.0604099  0.0145154  -4.162 0.000032135 ***
z.diff.lag5  0.0027824  0.0145444   0.191     0.84830    
z.diff.lag6 -0.0334936  0.0145159  -2.307     0.02108 *  
z.diff.lag7  0.0372310  0.0145171   2.565     0.01036 *  
z.diff.lag8 -0.0404052  0.0145189  -2.783     0.00541 ** 
z.diff.lag9  0.0577312  0.0144890   3.984 0.000068639 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 32.49 on 4763 degrees of freedom
Multiple R-squared:  0.02414,   Adjusted R-squared:  0.02189 
F-statistic: 10.71 on 11 and 4763 DF,  p-value: &lt; 0.00000000000000022


Value of test-statistic is: -0.9042 4.9486 3.7731 

Critical values for test statistics: 
      1pct  5pct 10pct
tau3 -3.96 -3.41 -3.12
phi2  6.09  4.68  4.03
phi3  8.27  6.25  5.34</code></pre>
</div>
</div>
<p>On commence d’abord par sélectionner le modèle à utiliser : avec constante et tendance, avec constante sans tendance ou sans constante ni tendance. On commence toujours par le modèle avec constante et tendance. Le paramètre de la tendance est donnée à la ligne <code>tt</code>. Attention, pour tester la significativité des paramètres, il faut utiliser les valeurs tabulées par Dickey-Fuller puisque les valeurs usuelles ne sont pas utilisables.</p>
<p>La valeur critique associée au coefficient de la tendance dans le modèle 3 et avec un nombre d’observations grand au seuil de 5% est <span class="math inline">\(2.78\)</span>. La t-value du coefficient de la tendance est de <span class="math inline">\(1.808 &lt; 2.78\)</span>. ON ne peut donc pas rejeter l’hypothèse nulle de non-significativité de la tendance. On rejette le modèle 3 et on passe au modèle avec constante et sans tendance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>urca<span class="sc">::</span><span class="fu">ur.df</span>(</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">y =</span> sp_500, <span class="co"># Série à utiliser</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"drift"</span>, <span class="co"># type de modèle ADF : ici sans tendance et avec constante</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">lags =</span> <span class="dv">10</span>, <span class="co"># nombre de lags maximum</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">selectlags =</span> <span class="st">"AIC"</span> <span class="co"># Sélection du nombre de lag avec le critère AIC</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>() <span class="co"># Donner un résummé du résultat</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
############################################### 
# Augmented Dickey-Fuller Test Unit Root Test # 
############################################### 

Test regression drift 


Call:
lm(formula = z.diff ~ z.lag.1 + 1 + z.diff.lag)

Residuals:
    Min      1Q  Median      3Q     Max 
-348.08  -10.46    1.17   12.60  432.47 

Coefficients:
              Estimate Std. Error t value   Pr(&gt;|t|)    
(Intercept) -0.4407891  0.9571793  -0.461    0.64517    
z.lag.1      0.0006483  0.0003135   2.068    0.03874 *  
z.diff.lag1 -0.0749087  0.0144806  -5.173 0.00000024 ***
z.diff.lag2  0.0357974  0.0145086   2.467    0.01365 *  
z.diff.lag3 -0.0389440  0.0145103  -2.684    0.00730 ** 
z.diff.lag4 -0.0610703  0.0145143  -4.208 0.00002628 ***
z.diff.lag5  0.0021777  0.0145440   0.150    0.88099    
z.diff.lag6 -0.0340639  0.0145159  -2.347    0.01898 *  
z.diff.lag7  0.0366844  0.0145174   2.527    0.01154 *  
z.diff.lag8 -0.0410067  0.0145185  -2.824    0.00476 ** 
z.diff.lag9  0.0571951  0.0144894   3.947 0.00008016 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 32.5 on 4764 degrees of freedom
Multiple R-squared:  0.02347,   Adjusted R-squared:  0.02142 
F-statistic: 11.45 on 10 and 4764 DF,  p-value: &lt; 0.00000000000000022


Value of test-statistic is: 2.0676 5.7855 

Critical values for test statistics: 
      1pct  5pct 10pct
tau2 -3.43 -2.86 -2.57
phi1  6.43  4.59  3.78</code></pre>
</div>
</div>
<p>On tester la significativité du paramètre de la constante <code>(Intercept)</code>. La valeur critique associée à la constante dans le modèle 2, avec un nombre grand d’observations et un seuil de 5% est de <span class="math inline">\(2.52\)</span>. La t-value associée au paramètre de la constante est de <span class="math inline">\(|-0.41| &lt; 2.52\)</span>. On ne peut donc pas rejeter l’hypothèse nulle de non significativité de la constante dans le modèle 2. On rejette ce modèle et on passe au modèle 1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>urca<span class="sc">::</span><span class="fu">ur.df</span>(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">y =</span> sp_500, <span class="co"># Série à utiliser</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"none"</span>, <span class="co"># type de modèle ADF : ici sans tendance et sans constante</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">lags =</span> <span class="dv">10</span>, <span class="co"># nombre de lags maximum</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">selectlags =</span> <span class="st">"AIC"</span> <span class="co"># Sélection du nombre de lag avec le critère AIC</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>() <span class="co"># Donner un résummé du résultat</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
############################################### 
# Augmented Dickey-Fuller Test Unit Root Test # 
############################################### 

Test regression none 


Call:
lm(formula = z.diff ~ z.lag.1 - 1 + z.diff.lag)

Residuals:
    Min      1Q  Median      3Q     Max 
-347.80  -10.65    1.00   12.45  432.78 

Coefficients:
              Estimate Std. Error t value    Pr(&gt;|t|)    
z.lag.1      0.0005228  0.0001551   3.371    0.000756 ***
z.diff.lag1 -0.0747333  0.0144744  -5.163 0.000000253 ***
z.diff.lag2  0.0359699  0.0145026   2.480    0.013163 *  
z.diff.lag3 -0.0387647  0.0145038  -2.673    0.007549 ** 
z.diff.lag4 -0.0608982  0.0145082  -4.197 0.000027481 ***
z.diff.lag5  0.0023484  0.0145381   0.162    0.871682    
z.diff.lag6 -0.0339034  0.0145105  -2.336    0.019508 *  
z.diff.lag7  0.0368449  0.0145120   2.539    0.011151 *  
z.diff.lag8 -0.0408408  0.0145128  -2.814    0.004911 ** 
z.diff.lag9  0.0573535  0.0144842   3.960 0.000076127 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 32.5 on 4765 degrees of freedom
Multiple R-squared:  0.02465,   Adjusted R-squared:  0.0226 
F-statistic: 12.04 on 10 and 4765 DF,  p-value: &lt; 0.00000000000000022


Value of test-statistic is: 3.3706 

Critical values for test statistics: 
      1pct  5pct 10pct
tau1 -2.58 -1.95 -1.62</code></pre>
</div>
</div>
<p>On va tester la significativité du terme auto-régressif en niveau <code>z.lag.1</code>. La valeur critique du coefficient pour le modèle 1, avec un grand nombre d’observations et un seuil de 5% est de <span class="math inline">\(-1.95\)</span>. La t-value du coefficient est : <span class="math inline">\(3.371 &gt; -1.95\)</span>. On rappelle que sur ce test de racine unitaire, la règle de décision est inversée. On rejetera l’hypothèse nulle de non-stationnarité lorsque la t-value et inférieure à la valeur critique (NE PAS PRENDRE LES VALEURS ABSOLUES ICI).</p>
<p>Notre t-value étant supérieure à la valeur critique, on ne peut pas rejeter l’hypothèse nulle de non stationnarité de la série. Notre série est vraisemblablement caractérisée par un processus <span class="math inline">\(I(1)\)</span> avec au moins une racine unitaire. Pour pouvoir l’utiliser dans des modélisations classiques, il faut la stationnariser.</p>
</section>
<section id="stationnarisation" class="level3">
<h3 class="anchored" data-anchor-id="stationnarisation">Stationnarisation</h3>
<p>Ici on va la log-différencier pour obtenir le changement en pourcentage de la série, autrement dit les rendements journaliers observés.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculer les rendements de la série</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Faire la log différence des données + retirer les valeurs manquantes</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>rend_sp_500 <span class="ot">&lt;-</span> </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">na.omit</span>((<span class="fu">log</span>(sp_500) <span class="sc">-</span> <span class="fu">log</span>(<span class="fu">lag</span>(sp_500))) <span class="sc">*</span> <span class="dv">100</span>) </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>rend_sp_500</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                 X.gspc
2007-01-04  0.122753250
2007-01-05 -0.610316783
2007-01-08  0.221785708
2007-01-09 -0.051680950
2007-01-10  0.193847181
2007-01-11  0.631986163
2007-01-12  0.484142709
2007-01-16  0.081746087
2007-01-17 -0.089433742
2007-01-18 -0.297516138
       ...             
2025-12-26 -0.030440988
2025-12-29 -0.349816292
2025-12-30 -0.137661425
2025-12-31 -0.738486743
2026-01-02  0.189291403
2026-01-05  0.633402451
2026-01-06  0.617759200
2026-01-07 -0.344585357
2026-01-08  0.007654533
2026-01-09  0.645461114</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>rend_sp_500 <span class="sc">|&gt;</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La série des rendements semble stationnaire en moyenne. En revanche, il semble que la volatilité ne soit pas constante au cours du temps. On remarque même des clusters de volatilités.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>rend_sp_500 <span class="sc">|&gt;</span> </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">acf</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La fonction d’auto-corrélation semble également indiquer que la série des rendements est une série stationnaire. On remarque qu’il y a de l’auto-corrélation significative jusqu’à l’ordre 15.</p>
<p>Malgré les “preuves” graphiques, nous allons tester la stationnarité des rendements.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># N'exécuter que si le package dobby est installé</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Test ADF automatique</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">adf_test_auto</span>(</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    rend_sp_500, </span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S&amp;P500"</span>, </span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">lags =</span> <span class="dv">20</span>, </span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_res =</span> <span class="cn">FALSE</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  ) </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

#################################################
# Augmented Dickey-Fuller test for S&amp;P500 serie #
#################################################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>model selected : Without drift and trend</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Lags number : 19</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : S&amp;P500 serie has at least one unit root</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>t stat : -15.4004792278914</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>✔ H0 is rejected with for 5% confidence. S&amp;P500 serie has no unit root.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code></code></pre>
</div>
</div>
<p>L’hypothèse nulle est rejetée, la série des rendements semble donc stationnaire en moyenne.</p>
</section>
<section id="description-des-rendements" class="level3">
<h3 class="anchored" data-anchor-id="description-des-rendements">Description des rendements</h3>
<p>On s’intéresse ensuite à la description statistique de notre série. On commence par observer la normalité de la série :</p>
<section id="normalité" class="level4">
<h4 class="anchored" data-anchor-id="normalité">Normalité</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Excuter uniquement si le package dobby est installé</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># tester la présence de skewness et de surplus de kurtosis</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_normality</span>(</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.numeric</span>(rend_sp_500), <span class="co"># Série : doit être un vecteur numérique   et pas une série temporelle</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S&amp;P500"</span>, <span class="co"># Nom à donner à la série</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_output =</span> <span class="cn">FALSE</span> <span class="co"># Faut-il retourner un tableau de résultats   ?</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  ) </span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

####################################
# Normality tests for S&amp;P500 serie #
####################################</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    D'Agostino skewness test

data:  serie
skew = -0.4741, z = -12.7543, p-value &lt; 0.00000000000000022
alternative hypothesis: data have a skewness


    Anscombe-Glynn kurtosis test

data:  serie
kurt = 15.466, z = 30.801, p-value &lt; 0.00000000000000022
alternative hypothesis: kurtosis is not equal to 3


    Jarque-Bera Normality Test

data:  serie
JB = 31162, p-value &lt; 0.00000000000000022
alternative hypothesis: greater</code></pre>
</div>
</div>
<p>Cette fonction exécute les fonctions <code>moments::agostino.test()</code> pour tester si la skewness de la série est statistiquement différente de 0 ou non ; <code>moments::anscombe.test()</code> pour tester si la kurtosis de la série est statistiquement différente de 3 ; <code>moments::jarque.test()</code> pour tester si la kurtosis et la skewness de la série sont conjointement différentes de 0 et 3 respectivement.</p>
<p>Les tests statistiques indiquent que notre série est biaisée à gauche avec une skewness négative. Cela indique que les pertes ont d’avantage d’impact que les gains. La série est également caractérisée par une kurtosis supérieure à 3 indiquant que la probabilité d’observer des valeurs extrêmes est bien plus élevée que dans une loi normale.</p>
<p>Le test joint indique que les moments de la série des rendements ne sont pas égaux aux moments de la loi normale. A priori nos rendements ne suivent pas une loi normale.</p>
<p>Si le package <code>dobby</code> n’est pas installé, il est possible de faire les tests un par un :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>moments<span class="sc">::</span><span class="fu">agostino.test</span>(rend_sp_500)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    D'Agostino skewness test

data:  rend_sp_500
skew = -0.4741, z = -12.7543, p-value &lt; 0.00000000000000022
alternative hypothesis: data have a skewness</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>moments<span class="sc">::</span><span class="fu">anscombe.test</span>(rend_sp_500)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Anscombe-Glynn kurtosis test

data:  rend_sp_500
kurt = 15.466, z = 30.801, p-value &lt; 0.00000000000000022
alternative hypothesis: kurtosis is not equal to 3</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>moments<span class="sc">::</span><span class="fu">jarque.test</span>(<span class="fu">as.numeric</span>(rend_sp_500))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Jarque-Bera Normality Test

data:  as.numeric(rend_sp_500)
JB = 31162, p-value &lt; 0.00000000000000022
alternative hypothesis: greater</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(rend_sp_500)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.03328781</code></pre>
</div>
</div>
<p>La moyenne de la série est proche de 0 comme le veut la théorie des marchés financier comme quoi en moyenne le gain est nul.</p>
</section>
<section id="auto-corrélation" class="level4">
<h4 class="anchored" data-anchor-id="auto-corrélation">Auto-corrélation</h4>
<p>On regarde ensuite l’auto-corrélation de la série avec les tests de Ljung-Box et Box-Pierce avec des ordres d’auto-corrélation de 1 et 20. Le package maison <code>dobby</code> utilise la fonction <code>stats::Box.test()</code> mais permet, entre autre, d’avoir des résultats pouvant être extraits.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter uniquement si le package dobby est installé</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">is_installed</span>(<span class="st">"dobby"</span>)){</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Test de Ljung-Box</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    rend_sp_500, <span class="co"># Série à tester</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S&amp;P500"</span>, <span class="co"># Nom à donner à la série</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">test_type =</span> <span class="st">"Ljung-Box"</span>, <span class="co"># Nom du test d'auto-corrélation</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_output =</span> <span class="cn">FALSE</span> <span class="co"># Faut-il retourner un tableau de résultats</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

#############################
# Ljung-Box test for S&amp;P500 #
#############################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'S&amp;P500' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Ljung test

data:  serie
X-squared = 71.853, df = 1, p-value &lt; 0.00000000000000022


[[2]]

    Box-Ljung test

data:  serie
X-squared = 170.47, df = 20, p-value &lt; 0.00000000000000022</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter uniquement si le package dobby est installé</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)){</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a> <span class="co"># Test de Box Pierce</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    rend_sp_500, </span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S&amp;P500"</span>, </span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">test_type =</span> <span class="st">"Box-Pierce"</span>, </span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_output =</span> <span class="cn">FALSE</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>  ) </span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

##############################
# Box-Pierce test for S&amp;P500 #
##############################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'S&amp;P500' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Pierce test

data:  serie
X-squared = 71.808, df = 1, p-value &lt; 0.00000000000000022


[[2]]

    Box-Pierce test

data:  serie
X-squared = 170.14, df = 20, p-value &lt; 0.00000000000000022</code></pre>
</div>
</div>
<p>Les tests de Box-Pierce et Ljung-Box indiquent tous les deux que la série présente de l’auto-corrélation à l’ordre 1 et 20 pour de très faibles niveaux de risque. L’objectif va être d’essayer de modéliser au maximum cette autocorrélation.</p>
</section>
</section>
</section>
<section id="modélisation-ar1" class="level2">
<h2 class="anchored" data-anchor-id="modélisation-ar1">Modélisation AR(1)</h2>
<p>Nous allons commencer par essayer de modéliser la série avec un <span class="math inline">\(AR(1)\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>ar_1 <span class="ot">&lt;-</span> </span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  forecast<span class="sc">::</span><span class="fu">Arima</span>(</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    rend_sp_500, <span class="co"># Série à modéliser</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="co"># Ordres AR, I, MA à utiliser</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">include.mean =</span> <span class="cn">TRUE</span> <span class="co"># Inclure une constante ou pas</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(ar_1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Series: rend_sp_500 
ARIMA(1,0,0) with non-zero mean 

Coefficients:
          ar1    mean
      -0.1225  0.0333
s.e.   0.0143  0.0160

sigma^2 = 1.547:  log likelihood = -7832.27
AIC=15670.53   AICc=15670.54   BIC=15689.95

Training set error measures:
                         ME     RMSE       MAE  MPE MAPE      MASE
Training set -0.00001384397 1.243459 0.8014404 -Inf  Inf 0.6665076
                      ACF1
Training set -0.0006646901</code></pre>
</div>
</div>
<p>Le modèle <span class="math inline">\(AR(1)\)</span> indique que les rendements dépendent de manière négative de leur valeur passé<span class="math inline">\(-0.1225\)</span>. Ce coefficient est significativement différent de 0 : <span class="math inline">\(|-0.1225/0.0143| \approx 8.57 &gt; 1.96\)</span>. On passe donc le test de surdimmensionnement.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Créer un dataframe pour visualiser les données</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ar_1$x permet de récupérer les données utilisées pour la modélisation</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ar_1_fitted permet de récupérer les valeurs prédites de la série</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">real_value =</span> <span class="fu">as.numeric</span>(ar_1<span class="sc">$</span>x), <span class="co"># Valeur réelle</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">fitted_value =</span> ar_1<span class="sc">$</span>fitted, <span class="co"># Valeur estimée</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">t =</span> <span class="fu">time</span>(ar_1<span class="sc">$</span>x) <span class="co"># Date</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pivoter en longueur pour avoir les valeurs dans une seule colonne</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Permet de facilement gérer les couleurs et légendes avec ggplot2</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">cols =</span> <span class="sc">!</span>t, <span class="co"># pivoter toutes les colones sauf la date</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_to =</span> <span class="st">"variable"</span>,</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">values_to =</span> <span class="st">"rendements"</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Garder uniquement les dernières observations pour plus de clarté</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">row_number</span>() <span class="sc">&gt;</span> <span class="dv">9000</span>) <span class="sc">|&gt;</span> </span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="at">n =</span> <span class="dv">10</span>) <span class="sc">|&gt;</span> </span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Faire un graphique simple</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> t, <span class="at">y =</span> rendements, <span class="at">color =</span> variable)) <span class="sc">+</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 570 × 3
   t          variable     rendements
   &lt;date&gt;     &lt;chr&gt;             &lt;dbl&gt;
 1 2024-11-19 real_value      0.396  
 2 2024-11-19 fitted_value   -0.0105 
 3 2024-11-20 real_value      0.00220
 4 2024-11-20 fitted_value   -0.0111 
 5 2024-11-21 real_value      0.533  
 6 2024-11-21 fitted_value    0.0371 
 7 2024-11-22 real_value      0.346  
 8 2024-11-22 fitted_value   -0.0279 
 9 2024-11-25 real_value      0.302  
10 2024-11-25 fitted_value   -0.00504
# ℹ 560 more rows</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-32-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>On remarque que l’on n’arrive pas bien à reproduire l’amplitude et la volatilité de la série.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    ar_1<span class="sc">$</span>residuals, </span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"résidus AR(1)"</span>,</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_output =</span> <span class="cn">TRUE</span> <span class="co"># Retourner graphiques + tableaux</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  )[<span class="dv">1</span>] <span class="co"># Simplement garder le 1er élément -&gt; les graphiques </span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

####################################
# Ljung-Box test for résidus AR(1) #
####################################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'résidus AR(1)' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Ljung test

data:  serie
X-squared = 0.0021154, df = 1, p-value = 0.9633


[[2]]

    Box-Ljung test

data:  serie
X-squared = 82.283, df = 20, p-value = 0.000000001603</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$graph</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-33-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Le test d’autocorrélation nous indique que toute l’autocorrélation de long-terme n’a pas été prise en compte. Le modèle n’est donc pas valide.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_normality</span>(</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.numeric</span>(rend_sp_500), </span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"résidus AR(1)"</span>, </span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">return_output =</span> <span class="cn">FALSE</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  ) </span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

###########################################
# Normality tests for résidus AR(1) serie #
###########################################</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    D'Agostino skewness test

data:  serie
skew = -0.4741, z = -12.7543, p-value &lt; 0.00000000000000022
alternative hypothesis: data have a skewness


    Anscombe-Glynn kurtosis test

data:  serie
kurt = 15.466, z = 30.801, p-value &lt; 0.00000000000000022
alternative hypothesis: kurtosis is not equal to 3


    Jarque-Bera Normality Test

data:  serie
JB = 31162, p-value &lt; 0.00000000000000022
alternative hypothesis: greater</code></pre>
</div>
</div>
<p>Comme prévu les résidus ne sont pas normaux. Cela est logique car rien dans la modélisation AR(1) ne permet de prendre en compte la non-normalité. De ce fait, on laissera pour les prochaines modélisations le test de normalité de côté.</p>
<p>On utilise le test de White pour tester l’homogénéité de la variance ainsi que le test ARCH :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test de white</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>whitestrap<span class="sc">::</span><span class="fu">white_test</span>(</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  ar_1 <span class="co"># Modèle dont les résidus sont à tester</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>White's test results

Null hypothesis: Homoskedasticity of the residuals
Alternative hypothesis: Heteroskedasticity of the residuals
Test Statistic: 377.67
P-value: 0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ARCH test</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>fDMA<span class="sc">::</span><span class="fu">archtest</span>(</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.numeric</span>(ar_1<span class="sc">$</span>residuals<span class="sc">**</span><span class="dv">2</span>), <span class="co"># Série des résidus au carré</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">lag =</span> <span class="dv">20</span> <span class="co"># nombre de lags à utiliser</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Engle's LM ARCH Test

data:  as.numeric(ar_1$residuals^2)
statistic = 1035.9, lag = 20, p-value &lt; 0.00000000000000022
alternative hypothesis: ARCH effects of order 20 are present</code></pre>
</div>
</div>
<p>L’hypothèse d’homogénéité de la variance est rejetée. La variance des résidus ne semble pas constante dans le temps et semble être conditionnellement autocorrélée.</p>
<p>La modélisation AR(1) ne semble donc pas suffisante pour modéliser correctement notre série des rendements.</p>
</section>
<section id="modélisation-armapq" class="level2">
<h2 class="anchored" data-anchor-id="modélisation-armapq">Modélisation ARMA(p,q)</h2>
<p>On peut utiliser la fonction <code>foreast::auto.arima()</code> pour déterminer le modèle qui correspond le mieux à nos données selon les critères d’informations. Cette fonction va déterminer le nombre de lags nécessaire pour modéliser notre série selon un critère dd’information</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Meilleur modèle selon les critères d'informations</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>best_arma <span class="ot">&lt;-</span> </span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  forecast<span class="sc">::</span><span class="fu">auto.arima</span>(rend_sp_500) <span class="sc">|&gt;</span> </span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Series: rend_sp_500 
ARIMA(4,0,5) with non-zero mean 

Coefficients:
          ar1     ar2      ar3      ar4     ma1      ma2    ma3     ma4
      -0.3156  0.8721  -0.2741  -0.8195  0.1968  -0.9112  0.383  0.7440
s.e.   0.0752  0.0745   0.0569   0.0524  0.0766   0.0771  0.063  0.0562
          ma5    mean
      -0.1075  0.0332
s.e.   0.0191  0.0152

sigma^2 = 1.534:  log likelihood = -7808.88
AIC=15639.77   AICc=15639.82   BIC=15710.97</code></pre>
</div>
</div>
<p>Il semble que selon le critère AIC, le meilleur modèle soit un <span class="math inline">\(ARMA(4,5)\)</span>. On va tester si les derniers coefficients sont significatifs ou non</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester la significativité des coefficients</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Créer un tibble contenant les coefficients</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">variable =</span> <span class="fu">names</span>(best_arma<span class="sc">$</span>coef), <span class="co"># Extraire le nom des coefficients</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">coef =</span> best_arma<span class="sc">$</span>coef, <span class="co"># Extraire la valeur des coefficients</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">std =</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(best_arma<span class="sc">$</span>var.coef)) <span class="co"># Extraire l'écart-type des coefficients à partir de la matrice de variance-covariance</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">t_stat =</span> <span class="fu">abs</span>(coef <span class="sc">/</span> std) <span class="co"># Calculer la t-stat de chaque coef</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 4
   variable     coef    std t_stat
   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
 1 ar1       -0.316  0.0752   4.19
 2 ar2        0.872  0.0745  11.7 
 3 ar3       -0.274  0.0569   4.81
 4 ar4       -0.820  0.0524  15.6 
 5 ma1        0.197  0.0766   2.57
 6 ma2       -0.911  0.0771  11.8 
 7 ma3        0.383  0.0630   6.08
 8 ma4        0.744  0.0562  13.2 
 9 ma5       -0.108  0.0191   5.62
10 intercept  0.0332 0.0152   2.19</code></pre>
</div>
</div>
<p>On remarque que tous nos coefficients passent le test de surdimmensionnement puisque toutes les t-stats sont supérieures à 1.96. le modèle est donc validé de ce point de vue. (Rappel que le test de surdimmensionnement ne s’applique en général que sur les derniers coefficients de chaque composante).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(best_arma<span class="sc">$</span>residuals, <span class="st">"residus"</span>)[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>

##############################
# Ljung-Box test for residus #
##############################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'residus' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Ljung test

data:  serie
X-squared = 0.0043245, df = 1, p-value = 0.9476


[[2]]

    Box-Ljung test

data:  serie
X-squared = 37.405, df = 20, p-value = 0.01046</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$graph</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-38-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La majorité de l’autocorrélation de la série semble avoir été prise en compte. Il n’y a pas à court-terme d’auto-corrélation. Par contre, on peut voir que le résultat est moins net à plus long-terme. Ici à l’ordre 20, on rejette l’hypothèse nulle de non-significativité à 5%.</p>
<p>La fonction <code>Box.Ljung.Text()</code> permet de tracer un graphique indiquant la p.value du test de Ljung-Box pour tous les horizons voulus. On remarque que l’on ne capte pas toute l’auto-corrélation de long-terme avec notre modélisation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>LSTS<span class="sc">::</span><span class="fu">Box.Ljung.Test</span>(best_arma<span class="sc">$</span>residuals, <span class="at">lag =</span> <span class="dv">40</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-39-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test de white</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>whitestrap<span class="sc">::</span><span class="fu">white_test</span>(best_arma)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>White's test results

Null hypothesis: Homoskedasticity of the residuals
Alternative hypothesis: Heteroskedasticity of the residuals
Test Statistic: 405.26
P-value: 0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ARCH test</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>fDMA<span class="sc">::</span><span class="fu">archtest</span>(<span class="fu">as.numeric</span>(best_arma<span class="sc">$</span>residuals<span class="sc">**</span><span class="dv">2</span>), <span class="at">lag =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Engle's LM ARCH Test

data:  as.numeric(best_arma$residuals^2)
statistic = 1057.6, lag = 20, p-value &lt; 0.00000000000000022
alternative hypothesis: ARCH effects of order 20 are present</code></pre>
</div>
</div>
<p>Encore une fois, nos résidus présentent des caractéristiques de variance non constante et de variance conditionnelle non-constante. Cela est normal puisque la modélisation ARMA ne permet pas de prendre en compte ce genre d’effets.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Créer un dataframe pour visualiser les données</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">real_value =</span> <span class="fu">as.numeric</span>(best_arma<span class="sc">$</span>x), <span class="co"># Valeur réelle</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">fitted_value =</span> best_arma<span class="sc">$</span>fitted, <span class="co"># Valeur estimée</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">t =</span> <span class="fu">time</span>(best_arma<span class="sc">$</span>x) <span class="co"># Date</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pivoter en longueur pour avoir les valeurs dans une seule colonne</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Permet de facilement gérer les couleurs et légendes avec ggplot2</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">cols =</span> <span class="sc">!</span>t,</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_to =</span> <span class="st">"variable"</span>,</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">values_to =</span> <span class="st">"rendements"</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Garder uniquement les dernières observations pour plus de clarté</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">row_number</span>() <span class="sc">&gt;</span> <span class="dv">9000</span>) <span class="sc">|&gt;</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> t, <span class="at">y =</span> rendements, <span class="at">color =</span> variable)) <span class="sc">+</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-41-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Encore une fois, la modélisation ARMA a du mal à reproduire l’amplitude de variation des rendements (ce qui est un cas classique).</p>
</section>
<section id="modélisation-de-marche-aléatoire" class="level2">
<h2 class="anchored" data-anchor-id="modélisation-de-marche-aléatoire">Modélisation de marche aléatoire</h2>
<p>Nous allons par la suite comparer la puissance prédictive de nos modèle entre eux mais également nous allons chercher à voir s’ils permettent de mieux prédire et d’expliquer les rendements que le hasard donné par la marche aléatoire.</p>
<p>Rappel qu’une marche aléatoire consiste à explique la valeur actuelle par la totalité de sa valeur passée (coefficient auto-régressif de 1). Il s’agit d’un <span class="math inline">\(ARIMA(0,1,0)\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>rw <span class="ot">&lt;-</span> <span class="fu">Arima</span>(rend_sp_500, <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Series: rend_sp_500 
ARIMA(0,1,0) 

sigma^2 = 3.525:  log likelihood = -9801.67
AIC=19605.33   AICc=19605.33   BIC=19611.81</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Créer un dataframe pour visualiser les données</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">real_value =</span> <span class="fu">as.numeric</span>(rw<span class="sc">$</span>x), <span class="co"># Valeur réelle</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">fitted_value =</span> rw<span class="sc">$</span>fitted, <span class="co"># Valeur estimée</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">t =</span> <span class="fu">time</span>(best_arma<span class="sc">$</span>x) <span class="co"># Date</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pivoter en longueur pour avoir les valeurs dans une seule colonne</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Permet de facilement gérer les couleurs et légendes avec ggplot2</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">cols =</span> <span class="sc">!</span>t,</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_to =</span> <span class="st">"variable"</span>,</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">values_to =</span> <span class="st">"rendements"</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Garder uniquement les dernières observations pour plus de clarté</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">row_number</span>() <span class="sc">&gt;</span> <span class="dv">9000</span>) <span class="sc">|&gt;</span> </span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>() <span class="sc">|&gt;</span> </span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> t, <span class="at">y =</span> rendements, <span class="at">color =</span> variable)) <span class="sc">+</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 570 × 3
       t variable     rendements
   &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;
 1  4501 real_value      0.396  
 2  4501 fitted_value    0.391  
 3  4502 real_value      0.00220
 4  4502 fitted_value    0.396  
 5  4503 real_value      0.533  
 6  4503 fitted_value    0.00220
 7  4504 real_value      0.346  
 8  4504 fitted_value    0.533  
 9  4505 real_value      0.302  
10  4505 fitted_value    0.346  
# ℹ 560 more rows</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-ARIMA_files/figure-html/unnamed-chunk-43-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>La marche aléatoire reproduit les variations mais avec un temps de retard puisque la valeur prédite en <span class="math inline">\(t\)</span> est simplement la valeur observée en <span class="math inline">\(t-1\)</span>.</p>
</section>
<section id="comparaison-in-sample" class="level2">
<h2 class="anchored" data-anchor-id="comparaison-in-sample">Comparaison in sample</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>models_RMSE <span class="ot">&lt;-</span> </span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pour chaque série de résidus, calculer le root mean square error</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dbl</span>(</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">list</span>(rw<span class="sc">$</span>residuals, ar_1<span class="sc">$</span>residuals, best_arma<span class="sc">$</span>residuals), </span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    \(epsilon) {<span class="fu">sqrt</span>(<span class="fu">mean</span>(epsilon<span class="sc">**</span><span class="dv">2</span>))}</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>models_MAE <span class="ot">&lt;-</span> </span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dbl</span>(</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">list</span>(rw<span class="sc">$</span>residuals, ar_1<span class="sc">$</span>residuals, best_arma<span class="sc">$</span>residuals), </span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    \(epsilon) {<span class="fu">mean</span>(<span class="fu">abs</span>(epsilon))}</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="fu">c</span>(<span class="st">"rw"</span>, <span class="st">"AR(1)"</span>, <span class="st">"best ARMA"</span>),</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">AIC =</span> <span class="fu">c</span>(<span class="fu">AIC</span>(rw), <span class="fu">AIC</span>(ar_1), <span class="fu">AIC</span>(best_arma)),</span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">BIC =</span> <span class="fu">c</span>(<span class="fu">BIC</span>(rw), <span class="fu">BIC</span>(ar_1), <span class="fu">BIC</span>(best_arma)),</span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>  <span class="at">RMSE =</span> models_RMSE,</span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>  <span class="at">MAE =</span> models_MAE</span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 5
  model        AIC    BIC  RMSE   MAE
  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 rw        19605. 19612.  1.88 1.20 
2 AR(1)     15671. 15690.  1.24 0.801
3 best ARMA 15640. 15711.  1.24 0.803</code></pre>
</div>
</div>
<p>Les critères de sélection de modèle semblent indiquer que l’ARMA(4,5) donne de meilleurs résultats au sein de l’échantillon. Mais cela semble quand même assez marginal.</p>
</section>
<section id="prévision-et-performance-out-of-sample" class="level2">
<h2 class="anchored" data-anchor-id="prévision-et-performance-out-of-sample">Prévision et performance out-of-sample</h2>
<p>Les modèles ARMA peuvent être utilisés pour faire de la prédiction :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Prédire les 10 prochains rendements</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>forecast<span class="sc">::</span><span class="fu">forecast</span>(best_arma, <span class="at">h =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Point Forecast     Lo 80    Hi 80     Lo 95    Hi 95
4786   -0.154847667 -1.742279 1.432584 -2.582614 2.272919
4787   -0.009891367 -1.608496 1.588713 -2.454746 2.434963
4788   -0.075004832 -1.673611 1.523601 -2.519862 2.369852
4789    0.040502204 -1.558130 1.639135 -2.404395 2.485399
4790    0.037691214 -1.562615 1.637997 -2.409766 2.485148
4791    0.103175863 -1.497207 1.703559 -2.344399 2.550750
4792    0.101756303 -1.500122 1.703635 -2.348106 2.551618
4793    0.065423975 -1.537177 1.668025 -2.385542 2.516390
4794    0.060007703 -1.542716 1.662732 -2.391147 2.511163
4795   -0.023243450 -1.626888 1.580401 -2.475806 2.429319</code></pre>
</div>
</div>
<p>Une façon de juger de la qualité d’un modèle est de tester sa capacité prédictive contre celle d’autres modèles. Pour cela, il faut tester le modèle out-of-sample. C’est à dire qu’il faut estimer le modèle sur un échantillon de test, prédire la prochaine valeur et la comparer avec la vraie valeur observée. Cela donne une erreur de prévision. Ensuite on ajoute la dernière valeur à l’échantillon et on répète le processus. On peut ensuite calculer la MAE ou RMSE de prévision du modèle et sélectionner le modèle qui en moyenne fait le moins d’erreurs.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction pour prédire à l'horizon de 1 jour et retourner un dataframe</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>func_predict <span class="ot">&lt;-</span> <span class="cf">function</span>(serie, <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), in_sample) {</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Condition pour ne pas estimer le modèle si la longueur de la série est inférieure à un scalaire donné</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(serie) <span class="sc">&gt;</span> in_sample) {</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Estimer le modèle</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    model <span class="ot">&lt;-</span> forecast<span class="sc">::</span><span class="fu">Arima</span>(serie, <span class="at">order =</span> order, <span class="at">include.mean =</span> <span class="cn">TRUE</span>) </span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prédire à l'horizon de 1 jour</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>    forecast_value <span class="ot">&lt;-</span> forecast<span class="sc">::</span><span class="fu">forecast</span>(model, <span class="at">h =</span> <span class="dv">1</span>) </span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Transformer le résultat en dataframe afin de pouvoir grouper les résultats</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>    df_forecast <span class="ot">&lt;-</span> </span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>      forecast_value <span class="sc">|&gt;</span> </span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">as_tibble</span>(<span class="at">rownames =</span> <span class="st">"obs"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>      janitor<span class="sc">::</span><span class="fu">clean_names</span>() <span class="sc">|&gt;</span> </span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">select</span>(obs, point_forecast)</span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(df_forecast)</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>   } </span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Faire la prédiction out-of-sample pour le meilleur arma trouvé. </span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="co"># in_sample = 4750 : on n'estime le modèle qu'une fois que l'on a au moins 4750 observations</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>pred_out_sample_best_arma <span class="ot">&lt;-</span> </span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>  runner<span class="sc">::</span><span class="fu">runner</span>(</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> rend_sp_500,</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">f =</span> \(y) <span class="fu">func_predict</span>(y, <span class="at">order =</span> best_arma<span class="sc">$</span>arma[<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">2</span>)], <span class="at">in_sample =</span> <span class="dv">4750</span>)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list_rbind</span>() <span class="sc">|&gt;</span> </span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">obs =</span> <span class="fu">as.numeric</span>(obs))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Faire la prédiction ouf-of-sample de l'AR(1)</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>pred_out_sample_ar_1 <span class="ot">&lt;-</span> </span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  runner<span class="sc">::</span><span class="fu">runner</span>(</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> rend_sp_500,</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">f =</span> \(y) <span class="fu">func_predict</span>(y, <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="at">in_sample =</span> <span class="dv">4750</span>)</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list_rbind</span>() <span class="sc">|&gt;</span> </span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">obs =</span> <span class="fu">as.numeric</span>(obs))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Faire la prédiction our-of-sample de la marche aléatoire</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>pred_out_sample_rw <span class="ot">&lt;-</span> </span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  runner<span class="sc">::</span><span class="fu">runner</span>(</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> rend_sp_500,</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">f =</span> \(y) <span class="fu">func_predict</span>(y, <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>), <span class="at">in_sample =</span> <span class="dv">4750</span>)</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list_rbind</span>() <span class="sc">|&gt;</span> </span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">obs =</span> <span class="fu">as.numeric</span>(obs))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>df_error_pred <span class="ot">&lt;-</span> </span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>  rend_sp_500 <span class="sc">|&gt;</span> </span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span> </span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">clean_names</span>() <span class="sc">|&gt;</span> </span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">obs =</span> <span class="fu">row_number</span>()) <span class="sc">|&gt;</span> </span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Joindre les tableaux de résultats estimés précédement</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">right_join</span>(</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    pred_out_sample_best_arma <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">point_forecast_best_arma =</span> point_forecast),</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">join_by</span>(obs <span class="sc">==</span> obs)</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">right_join</span>(</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>    pred_out_sample_ar_1 <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">point_forecast_ar_1 =</span> point_forecast),</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">join_by</span>(obs <span class="sc">==</span> obs)</span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">right_join</span>(</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>    pred_out_sample_rw <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">point_forecast_rw =</span> point_forecast),</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">join_by</span>(obs <span class="sc">==</span> obs)</span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">error_pred_best_arma =</span> gspc <span class="sc">-</span> point_forecast_best_arma,</span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">error_pred_ar_1 =</span> gspc <span class="sc">-</span> point_forecast_ar_1,</span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">error_pred_rw =</span> gspc <span class="sc">-</span> point_forecast_rw</span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Mettre toutes les erreures de prévision en colonne pour pouvoir calculer facilement les statistiques</span></span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="fu">starts_with</span>(<span class="st">"error_pred"</span>)) </span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculer la MAE et la RMSE pour les prédictions ou-of-sample</span></span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a>df_error_pred <span class="sc">|&gt;</span> </span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">cols =</span> <span class="fu">everything</span>(),</span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_to =</span> <span class="st">"model"</span>,</span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>    <span class="at">values_to =</span> <span class="st">"error_pred"</span></span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">drop_na</span>() <span class="sc">|&gt;</span> </span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(</span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a>    <span class="at">.by =</span> model,</span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a>    <span class="at">RMSE =</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>(error_pred<span class="sc">**</span><span class="dv">2</span>)),</span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a>    <span class="at">MAE =</span> <span class="fu">mean</span>(<span class="fu">abs</span>(error_pred))</span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 3
  model                 RMSE   MAE
  &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt;
1 error_pred_best_arma 0.643 0.522
2 error_pred_ar_1      0.681 0.551
3 error_pred_rw        0.847 0.614</code></pre>
</div>
</div>
<p>Notre <span class="math inline">\(ARMA(4,5)\)</span> est le modèle qui permet le mieux en moyenne de prédire de façon out-of-sample. Attention cela ne veut pas dire qu’il prédit bien. On la juste comparer à d’autres modèles et sur une très petite période pour éviter les longs temps de computation. Il est fort probable au vu des valeurs prédites en échantillon que ce modèle prédise très mal les rendements. Cela semble en ligne avec la théorie des marchés financiers qui veut que les rendements soient imprévisibles.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>