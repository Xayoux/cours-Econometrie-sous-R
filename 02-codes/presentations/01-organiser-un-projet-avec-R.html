<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Romain CAPLIEZ">

<title>Organiser un projet avec R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="01-organiser-un-projet-avec-R_files/libs/clipboard/clipboard.min.js"></script>
<script src="01-organiser-un-projet-avec-R_files/libs/quarto-html/quarto.js"></script>
<script src="01-organiser-un-projet-avec-R_files/libs/quarto-html/popper.min.js"></script>
<script src="01-organiser-un-projet-avec-R_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="01-organiser-un-projet-avec-R_files/libs/quarto-html/anchor.min.js"></script>
<link href="01-organiser-un-projet-avec-R_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="01-organiser-un-projet-avec-R_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="01-organiser-un-projet-avec-R_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="01-organiser-un-projet-avec-R_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="01-organiser-un-projet-avec-R_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Organiser un projet avec R</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Romain CAPLIEZ </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="organiser-un-projet-avec-r" class="level1">
<h1>Organiser un projet avec R</h1>
<section id="les-chemins-daccès" class="level2">
<h2 class="anchored" data-anchor-id="les-chemins-daccès">Les chemins d’accès</h2>
<p>Un projet économétrique doit être reproductible avec le moins d’intervention humaine possible. Dans l’idéal, la personne souhaitant reproduire l’analyse doit simplement avoir à exécuter le code. Moins il y a d’interventions à faire, mieux c’est. Cela évite les erreurs et permet de s’assurer un maximum qu’il n’y a pas eu de fraude lors de l’analyse.</p>
<p>Un point qui pose souvent problème lorsque l’on donne un code à un personne est la gestion des “chemins” dit “paths”. Ces chemins prennent la forme de chaînes de caractères du type “<em>D:/cours/Econométrie sous R</em>”. Ces chemins diffèrent selon l’opérateur système utilisé (Windows, MAC OS, Linux) et selon les personnes puisque l’organisation interne d’un ordinateur est personnel.</p>
<p>Il existe deux manières générales d’écrire les chemins d’accès : absolues et relatives. La manière absolue consiste à écrire le chemin d’accès complet. La manière relative consiste à uniquement écrire le chemin d’accès à partir d’une certaine source.</p>
<p>Généralement pour éviter d’avoir à changer tous les chemins d’accès d’un fichier, on définit un répertoire de travail à partir duquel on va pouvoir écrire les chemins d’accès en relatif.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sans définir de répetoire de travail </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Ce chemin d'accès est personnel et doit être changé à chaque changement d'ordinateur</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>readr<span class="sc">::</span><span class="fu">read_csv</span>(<span class="st">"D:/cours/Econométrie sous R/01-raw-data/iris.csv"</span>) <span class="sc">|&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># En définissant un répetoire de travail </span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Il suffit maintenant de juste modifier ce chemin d'accès par utilisateur</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">setwd</span>(<span class="st">"D:/cours/Econométrie sous R"</span>) <span class="co">#ne fonctionne pas à cause du projet R : on ne change pas de répertoire de travail</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># On peut écrire le chemin d'accès de manière relative à ce répertoire de tavail </span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Ces chemins d'accès n'auront pas besoin d'être modifiés si l'organisation interne du dossier n'est pas modifiée</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>readr<span class="sc">::</span><span class="fu">read_csv</span>(<span class="st">"01-raw-data/iris.csv"</span>) <span class="sc">|&gt;</span>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Cette manière de définir un répertoire de travail via la fonction <code>setwd()</code> est un premier pas dans la reproductibilité mais n’est pas optimale puisque chaque utilisateur doit changer ce répertoire de travail à sa convenance.</p>
<p>Pour pallier ce problème (entre autre), on va utiliser les “Projets R”. Créer un “Projet R” va permettre entre autre chose de disposer d’une session R propre à chaque projet que l’on a et va automatiquement définir le répertoire de travail au niveau de ce projet. Un “Projet R” prend la forme d’un fichier .Rproj que l’on va créer au niveau le plus élevé de notre dossier contenant notre projet.</p>
<p>On peut créer un projet de manière “manuelle” de la façon suivante :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/creer-projet-R-1-01.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/creer-projet-R-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/creer-projet-R-3.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Ou bien en utilisant la commande <code>usethis::create_project("D:/cours/Econometrie sous R").</code></p>
<p>Une fois le “Projet R” créé, il suffit de lancer la session à partir du fichier .Rproj.</p>
<p>A partir de là, une manière très simple de créer ses chemins d’accès est d’utiliser la fonction <code>here</code> du package <code>here</code>. Cette fonction utilisée sans arguments supplémentaires va renvoyer une chaîne de caractère indiquant le chemin d’accès absolu jusqu’au répertoire de travail :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>here<span class="sc">::</span><span class="fu">here</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "C:/Users/romai/OneDrive/Documents/cours-Econometrie-sous-R"</code></pre>
</div>
</div>
<p>Chaque argument passé à cette fonction est une chaîne de caractère qui correspond à un sous-dossier ou un fichier. La fonction <code>here</code> va créer le chemin absolu jusqu’à ce sous-dossier ou ce fichier.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"01-raw-data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "C:/Users/romai/OneDrive/Documents/cours-Econometrie-sous-R/01-raw-data"</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importer le dataframe iris avec la fonction here</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>readr<span class="sc">::</span><span class="fu">read_csv</span>(</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"01-raw-data"</span>, <span class="st">"iris.csv"</span>),</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">show_col_types =</span> <span class="cn">FALSE</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 5
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
1          5.1         3.5          1.4         0.2 setosa 
2          4.9         3            1.4         0.2 setosa 
3          4.7         3.2          1.3         0.2 setosa 
4          4.6         3.1          1.5         0.2 setosa 
5          5           3.6          1.4         0.2 setosa 
6          5.4         3.9          1.7         0.4 setosa </code></pre>
</div>
</div>
<p>L’utilisation d’un “Projet R” et de la fonction <code>here</code> permet d’éviter tout changement manuel de chemin d’accès et est un moyen (nécessaire mais pas suffisant) d’assurer un maximum de reproductibilité.</p>
</section>
<section id="structure-du-dossier" class="level2">
<h2 class="anchored" data-anchor-id="structure-du-dossier">Structure du dossier</h2>
<p>Afin de gagner du temps, de la productivité et de permettre une relecture facilitée du projet, il est essentiel d’avoir une organisation rigoureuse et propre de son dossier de travail. Chacun dispose de sa manière de travailler et d’organiser les choses. La manière présentée ici n’est peut-être pas celle qui est optimale et va correspondre à tout le monde.</p>
<p>Ma structure de base (qui évolue selon les projets et les besoins) est de la forme suivante :</p>
<ul>
<li><p><code>00-...</code> : Dossier quelconque, généralement des notes sur le projet en cours</p></li>
<li><p><code>01-raw-data</code> : Dossier dans lequel sont conservées les données brutes. <strong>Aucune modification ne doit être effectuée sur ces données</strong>.</p></li>
<li><p><code>02-codes</code> : Dossier contenant les scripts principaux de l’analyse ainsi que des sous-dossiers utilitaires (voir plus loin).</p></li>
<li><p><code>03-processed-data</code> : Dossier contenant les données modifiées et enregistrées.</p></li>
<li><p><code>04-output</code> : Dossier contenant les résultats (souvent des graphiques et des tables) enregistrés.</p>
<ul>
<li><p><code>graphs</code> : Sous-dossier contenant les graphiques.</p></li>
<li><p><code>tables</code> : Sous-dossier contenant les tables LaTeX.</p></li>
<li><p><code>Robjects</code> : Sous-dossier contenant les objets R (les estimations généralement).</p></li>
</ul></li>
<li><p><code>05-text</code> : Dossier contenant les fichier permettant d’écrire le rendu final / les rendus finaux (par soucis de reproductibilité immédiate je recommande d’écrire l’article en local et non pas sous Overleaf, ou au moins d’avoir une copie en local).</p>
<ul>
<li>1 sous dossier par rendu</li>
</ul></li>
<li><p><code>Projet.Rproj</code> : le fichier <code>Rproj</code> permettant de créer le projet R</p></li>
<li><p><code>README</code> : Un fichier (Markdown, Word, txt…) qui explique comment exécuter l’analyse et obtenir les résultats présentés dans l’article. Il est important de bien indiquer les packages utilisés, les configurations requises et tout élément nécessaire à la reproduction de l’analyse.</p></li>
</ul>
<p>D’autres fichiers et dossiers peuvent être présent à ce niveau suivant les besoins spécifiques d’une personne ou d’un projet.</p>
</section>
<section id="git-et-github" class="level2">
<h2 class="anchored" data-anchor-id="git-et-github">Git et Github</h2>
<p>Un moyen de transmettre son projet ainsi que de garder un oeuil sur son évolution sans avoir à faire des dizaines de “fichier-final-V2-final” est d’utiliser Git et Github. Voir <a href="https://happygitwithr.com">Happy Git and GitHub for the useR</a> pour l’installation et le fonctionnement de base.</p>
</section>
<section id="renv" class="level2">
<h2 class="anchored" data-anchor-id="renv">Renv</h2>
<p>Un des problème majeur de la reproductibilité est de s’assurer que toutes les fonctions utilisées soient pérennes dans le temps. Or R gère assez mal l’évolution dans le temps des packages. Il est possible que les fonctions utilisées changent ou ne soient plus disponibles une fois passé un certain temps. Le plus robuste est d’utiliser uniquement les fonction de base de R qui sont les moins susceptibles de changer. Cependant, cela implique de devoir tout recréer manuellement.</p>
<p>Si l’on utilise des packages, il convient dans un premier temps de noter tous les packages utilisés et leur version ainsi que la version de R utilisée.</p>
<p>Il est également possible d’utiliser le package <code>renv</code> qui permet de télécharger les packages en local et ainsi de les garder disponible dans leur version actuelle pour le futur et les autres utilisateurs. <code>renv</code> va permettre aux autre utilisateurs de télécharger les packages dans la même version que celle utilisée par l’auteur du projet de base.</p>
<p>ATTENTION ! Pour les utilisateurs de Windows, pour pouvoir utiliser correctement <code>renv</code> vous devez d’abord télécharger <a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a>.</p>
<p>Voici une introduction au fonctionnement de <a href="https://rstudio.github.io/renv/articles/renv.html">Renv</a>.</p>
</section>
<section id="organisation-du-code" class="level2">
<h2 class="anchored" data-anchor-id="organisation-du-code">Organisation du code</h2>
<p>Organiser son code pour le rendre lisible, compréhensible et facile à exécuter est également extrêmement important.</p>
<p>R est un programme que l’on va faire fonctionner ligne par ligne le plus souvent. Mis à part pour la reproductibilité, on va assez rarement exécuter tout le code d’un seul bloc. On va plutôt faire une estimation, regarder les résultats, changer quelque chose dans les données, refaire une estimation etc…</p>
<p>A cause de ce fonctionnement, il est assez facile d’obtenir un code brouillon dans lequel on doit se balader pour exécuter des bouts de code par-ci par-là.</p>
<p>Pour éviter cela je recommande de ne pas raisonner de manière linéaire dans le script mais plutôt de raisonner d’une manière plus “opérationnelle”.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Un raisonnement linéaire sur une modélisation ARMA : </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) Importer les packages</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) Importer les données</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) Tester la stationnarité</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) Différencier les données non stationnaires</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 5) Retester la stationnarité</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 6) Modéliser la série par un ARMA</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 7) Etudier les résultats</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 8) Sortir les graphs et tables</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Lors de l’écriture initiale, cela ne pose pas de problème. Mais lorsque l’on revient plus tard et que l’on souhaite uniquement revoir les tables et les graphs, on doit exécuter la ligne 1, 2, 4, 6 et 8. Sur un petit code cela n’est pas gênant de sauter des lignes (même si à la longue quand on fait des tests ça devient usant) mais sur des projets où les codes font parfois des milliers de lignes avec de dizaines d’éléments différents, cela devient vite un calvaire de savoir ce que l’on veut exécuter ou pas.</p>
<p>La manière dont je procède est de créer des scripts avec des buts bien définis plutôt que des scripts généraux. Ainsi dans mon dossier <code>02-codes</code>, je vais avoir un fichier <code>create-data.R</code> dans lequel je vais avoir le script dans lequel je crée toutes les données (avec les données différenciées etc…), un fichier <code>estimations.R</code> dans lequel je vais procéder à l’estimation et l’enregistrement des résultats (enregistrer les objets R dans un dossier particulier) et un fichier <code>analyse.R</code> dans lequel je vais mener l’analyse sur les estimations, faire les tables, les graphs, l’analyse de données etc…</p>
<p>Cela implique de faire des allers-retours entre les différents scripts mais permet une relecture et une re-exécution plus facile et compréhensible.</p>
<p>La deuxième chose que je recommande est d’éviter au sein d’un script d’avoir des blocs de code spécifiques à exécuter avant d’exécuter ce que je veux. Pour cela, j’organise de manière rigoureuse mon script afin que ce que j’ai à exécuter impérativement ensemble se trouve dans la même section/sous-section sans aucune ambiguïté.</p>
<p>Enfin, la première ligne de mon script est toujours une exécution d’un “setup” c’est à dire d’un code qui va me charger tout ce dont j’ai besoin peu importe le script dans lequel je suis : packages, données, chemins d’accès, objets R, preset de graphiques, fonctions, etc… grâce à la fonction <code>source("path-to-setup.R")</code> qui permet d’exécuter un script R.</p>
<p>Mon dossier Code ressemble donc à :</p>
<ul>
<li><p><code>02-codes</code></p>
<ul>
<li><p><code>create-data.R</code> : Code R dans lequel je crée toutes les données des plus basiques aux plus avancées</p></li>
<li><p><code>estimation.R</code> : Code R dans lequel je fais toutes les estimations à faire dans l’étude</p></li>
<li><p><code>analyse.R</code> : Code R dans lequel je procède à l’analyse et à l’enregistrement des résultats</p></li>
<li><p><code>functions_R</code> : Dossier dans lequel chaque fonction R créée et utilisée va être enregistrée dans un fichier <code>.R</code> spécifique portant le même nom que la fonction.</p></li>
<li><p><code>utils</code> : Dossier dans lequel vont se trouver tous les scripts utilitaires qui vont être appelés au début de chaque script principal.</p>
<ul>
<li><p><code>setup.R</code> : Code R qui va être exécuté au début de chaque script principal et qui va importer et charger tous les éléments contenus dans les autres scripts utilitaires. Il contient également les packages à charger, les conflits de fonction, la création des dossiers, les styles de graphiques etc…</p></li>
<li><p><code>paths.R</code> : Code R qui contient des chemins d’accès enregistrés dans des variables afin de ne pas avoir à toujours les renseigner. Tous les paths sont créés avec la fonction <code>here()</code>.</p></li>
<li><p><code>import-processed-data.R</code> : Code R qui va importer les données “processed” utilisées dans l’analyse si elles sont déjà créées (conditions nécessaire à mettre lorsque l’on passe le code à une autre personne qui n’aura pas ces données déjà créées).</p></li>
<li><p><code>.R</code> : Code R qui contient ce qui doit être chargé de spécifique au projet.</p></li>
</ul></li>
</ul></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>