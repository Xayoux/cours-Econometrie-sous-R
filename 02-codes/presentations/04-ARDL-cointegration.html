<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Romain CAPLIEZ">

<title>ARDL et cointégration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="04-ARDL-cointegration_files/libs/clipboard/clipboard.min.js"></script>
<script src="04-ARDL-cointegration_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="04-ARDL-cointegration_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="04-ARDL-cointegration_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="04-ARDL-cointegration_files/libs/quarto-html/popper.min.js"></script>
<script src="04-ARDL-cointegration_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="04-ARDL-cointegration_files/libs/quarto-html/anchor.min.js"></script>
<link href="04-ARDL-cointegration_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="04-ARDL-cointegration_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="04-ARDL-cointegration_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="04-ARDL-cointegration_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="04-ARDL-cointegration_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#théorie" id="toc-théorie" class="nav-link active" data-scroll-target="#théorie">Théorie</a>
  <ul class="collapse">
  <li><a href="#hypothèses-classiques-des-mco-en-séries-temporelles" id="toc-hypothèses-classiques-des-mco-en-séries-temporelles" class="nav-link" data-scroll-target="#hypothèses-classiques-des-mco-en-séries-temporelles">Hypothèses classiques des MCO en séries temporelles</a></li>
  <li><a href="#propriétés-asymptotiques-des-mco" id="toc-propriétés-asymptotiques-des-mco" class="nav-link" data-scroll-target="#propriétés-asymptotiques-des-mco">Propriétés asymptotiques des MCO</a></li>
  <li><a href="#modèles-à-retards-distribués-dl" id="toc-modèles-à-retards-distribués-dl" class="nav-link" data-scroll-target="#modèles-à-retards-distribués-dl">Modèles à Retards Distribués (DL)</a></li>
  <li><a href="#multiplicateurs-et-effets-marginaux" id="toc-multiplicateurs-et-effets-marginaux" class="nav-link" data-scroll-target="#multiplicateurs-et-effets-marginaux">Multiplicateurs et effets marginaux</a>
  <ul class="collapse">
  <li><a href="#dans-un-modèle-statique" id="toc-dans-un-modèle-statique" class="nav-link" data-scroll-target="#dans-un-modèle-statique">Dans un modèle statique</a></li>
  <li><a href="#dans-un-modèle-à-retards-distribués" id="toc-dans-un-modèle-à-retards-distribués" class="nav-link" data-scroll-target="#dans-un-modèle-à-retards-distribués">Dans un modèle à retards distribués</a></li>
  </ul></li>
  <li><a href="#modèles-auto-régressifs-à-retards-distribués-ardl" id="toc-modèles-auto-régressifs-à-retards-distribués-ardl" class="nav-link" data-scroll-target="#modèles-auto-régressifs-à-retards-distribués-ardl">Modèles Auto-Régressifs à Retards Distribués (ARDL)</a></li>
  <li><a href="#cointégration" id="toc-cointégration" class="nav-link" data-scroll-target="#cointégration">Cointégration</a></li>
  <li><a href="#modèles-à-correction-derreur" id="toc-modèles-à-correction-derreur" class="nav-link" data-scroll-target="#modèles-à-correction-derreur">Modèles à correction d’erreur</a></li>
  <li><a href="#procédure-dengle-granger" id="toc-procédure-dengle-granger" class="nav-link" data-scroll-target="#procédure-dengle-granger">Procédure d’Engle-Granger</a>
  <ul class="collapse">
  <li><a href="#ère-étape-tester-lexistence-de-la-cointégration" id="toc-ère-étape-tester-lexistence-de-la-cointégration" class="nav-link" data-scroll-target="#ère-étape-tester-lexistence-de-la-cointégration">1ère étape : Tester l’existence de la cointégration</a></li>
  <li><a href="#ème-étape-estimer-le-modèle-à-correction-derreur" id="toc-ème-étape-estimer-le-modèle-à-correction-derreur" class="nav-link" data-scroll-target="#ème-étape-estimer-le-modèle-à-correction-derreur">2ème étape : Estimer le modèle à correction d’erreur</a></li>
  </ul></li>
  <li><a href="#extension-de-la-cointégration" id="toc-extension-de-la-cointégration" class="nav-link" data-scroll-target="#extension-de-la-cointégration">Extension de la cointégration</a>
  <ul class="collapse">
  <li><a href="#modèle-ardl-général" id="toc-modèle-ardl-général" class="nav-link" data-scroll-target="#modèle-ardl-général">Modèle ARDL général</a></li>
  <li><a href="#modèle-unrestricted-error-correction-model-uecm" id="toc-modèle-unrestricted-error-correction-model-uecm" class="nav-link" data-scroll-target="#modèle-unrestricted-error-correction-model-uecm">Modèle Unrestricted Error Correction Model (UECM)</a></li>
  <li><a href="#modèle-restricted-error-correction-model-recm" id="toc-modèle-restricted-error-correction-model-recm" class="nav-link" data-scroll-target="#modèle-restricted-error-correction-model-recm">Modèle Restricted Error Correction Model (RECM)</a></li>
  <li><a href="#bound-f-test-bound-t-test" id="toc-bound-f-test-bound-t-test" class="nav-link" data-scroll-target="#bound-f-test-bound-t-test">Bound F test / Bound t test</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#code" id="toc-code" class="nav-link" data-scroll-target="#code">Code</a>
  <ul class="collapse">
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#présentation-des-données" id="toc-présentation-des-données" class="nav-link" data-scroll-target="#présentation-des-données">Présentation des données</a></li>
  <li><a href="#régression-statique" id="toc-régression-statique" class="nav-link" data-scroll-target="#régression-statique">Régression statique</a></li>
  <li><a href="#régression-avec-variable-dépendante-retardée" id="toc-régression-avec-variable-dépendante-retardée" class="nav-link" data-scroll-target="#régression-avec-variable-dépendante-retardée">Régression avec variable dépendante retardée</a></li>
  <li><a href="#modélisation-ardl" id="toc-modélisation-ardl" class="nav-link" data-scroll-target="#modélisation-ardl">Modélisation ARDL</a></li>
  <li><a href="#procédure-de-pesaran-et-al-2001" id="toc-procédure-de-pesaran-et-al-2001" class="nav-link" data-scroll-target="#procédure-de-pesaran-et-al-2001">Procédure de Pesaran et al (2001)</a>
  <ul class="collapse">
  <li><a href="#estimation-de-lardl-en-niveau" id="toc-estimation-de-lardl-en-niveau" class="nav-link" data-scroll-target="#estimation-de-lardl-en-niveau">Estimation de l’ARDL en niveau</a></li>
  <li><a href="#tester-la-sphéricité-des-erreurs" id="toc-tester-la-sphéricité-des-erreurs" class="nav-link" data-scroll-target="#tester-la-sphéricité-des-erreurs">Tester la sphéricité des erreurs</a></li>
  <li><a href="#corriger-lhétéroscédasticité" id="toc-corriger-lhétéroscédasticité" class="nav-link" data-scroll-target="#corriger-lhétéroscédasticité">Corriger l’hétéroscédasticité</a></li>
  <li><a href="#tester-la-présence-dune-relation-en-niveau" id="toc-tester-la-présence-dune-relation-en-niveau" class="nav-link" data-scroll-target="#tester-la-présence-dune-relation-en-niveau">Tester la présence d’une relation en niveau</a></li>
  <li><a href="#multiplicateurs" id="toc-multiplicateurs" class="nav-link" data-scroll-target="#multiplicateurs">Multiplicateurs</a></li>
  <li><a href="#relation-de-long-terme-et-vitesse-dajustement" id="toc-relation-de-long-terme-et-vitesse-dajustement" class="nav-link" data-scroll-target="#relation-de-long-terme-et-vitesse-dajustement">Relation de long-terme et vitesse d’ajustement</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ARDL et cointégration</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Romain CAPLIEZ </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="théorie" class="level1">
<h1>Théorie</h1>
<p>Comme vu au cours du chapitre 3, une série temporelle peut être expliquée par ses propres valeurs passées et les chocs quelle a subi au cours du passé. Cependant, compter uniquement sur l’information disponible par cette série peut être limité. Ajouter de l’information supplémentaire peut être utile afin d’étudier des liens de causalité ou bien afin d’améliorer la qualité de la prévision effectuée.</p>
<p>Il est possible d’enrichir les processus autoprojectifs en intégrant des informations apportées par des variables exogènes.</p>
<section id="hypothèses-classiques-des-mco-en-séries-temporelles" class="level2">
<h2 class="anchored" data-anchor-id="hypothèses-classiques-des-mco-en-séries-temporelles">Hypothèses classiques des MCO en séries temporelles</h2>
<p>Tout comme pour les données en coupe transversales, il existe des hypothèses permettant d’assurer que les estimateurs MCO en séries temporelles soient sans biais et de variance minimale tout en permettant de mener une analyse d’inférence.</p>
<ul>
<li><strong>Hypothèse TS.1</strong> <strong>:</strong> <strong>Linéarité des paramètres</strong></li>
</ul>
<p>Le processus stochastique <span class="math inline">\(\{(x_{t,1}, x_{t,2}, \dots, x_{t,k}, y_t)\}\)</span> : <span class="math inline">\(t=1, 2, \dots, n\)</span> suit un modèle linéaire dans ses paramètres :</p>
<p><span class="math display">\[
y_t = \alpha + \beta_1 X_{1t} + \dots + \beta_k X_{kt} + u_t
\]</span></p>
<p>Où <span class="math inline">\(u_t\)</span> correspond à la série des erreurs et <span class="math inline">\(n\)</span> le nombre de périodes temps (observations) de l’échantillon.</p>
<ul>
<li><strong>Hypothèse TS.2 : Absence de colinéarité parfaite</strong></li>
</ul>
<p>Dans l’échantillon (et donc dans le processus temporel sous-jacent), aucune variable explicative n’est une constante ou une combinaison linéaire parfaite d’autres variables explicatives.</p>
<p>Cette hypothèse autorise une certaine corrélation entre les variables explicatives tant que celles-ci ne sont pas parfaitement corrélées dans l’échantillon.</p>
<p>Si cette hypothèse n’est pas vérifiée le modèle n’est pas identifiable.</p>
<ul>
<li><strong>Hypothèse TS.3 : Espérance conditionnelle nulle</strong></li>
</ul>
<p>Pour chaque <span class="math inline">\(t\)</span>, l’espérance mathématique du terme d’erreur <span class="math inline">\(u_t\)</span> compte tenu des variables explicatives pour toutes les périodes est égale à 0.</p>
<p><span class="math display">\[
E(u_t|\mathbf{X}) = 0, \hspace{0.2cm} t = 1, 2, \dots, n
\]</span></p>
<p>Cette hypothèse indique que l’erreur à l’instant <span class="math inline">\(t\)</span> ne doit pas être corrélée de quelque manière que ce soit avec les variables explicatives pour chaque période de temps. Les variables doivent être strictement exogènes. Ce qui est une hypothèse plus stricte que la seule exogénéité contemporaine <span class="math inline">\(E(u_t|\mathbf{X}_t) = 0, \hspace{0.2cm} t = 1, 2, \dots, n\)</span>.</p>
<p>Sous les hypothèses TS.1 à TS.3 les estimateurs MCO en série temporelle sont sans biais.</p>
<ul>
<li><strong>Hypothèse TS.4 : Homoscédasticité</strong></li>
</ul>
<p>Conditionnellement à <span class="math inline">\(X\)</span>, la variance de <span class="math inline">\(u_t\)</span> est la même pour tout <span class="math inline">\(t\)</span> : <span class="math inline">\(Var(u_t | X) = Var(u_t) = \sigma^2 \text{ , } t = 1, 2, \dots, n\)</span>. Cela signifie que la variance conditionnelle des erreurs ne doit pas dépendre des variables explicatives (il suffit pour cela que <span class="math inline">\(u_t\)</span> et <span class="math inline">\(X\)</span> soient indépendants) et que la variance des erreurs soit constante au cours du temps.</p>
<ul>
<li><strong>Hypothèse TS.5 : Absence d’autocorrélation</strong></li>
</ul>
<p>Conditionnellement à <span class="math inline">\(X\)</span>, les erreurs à deux périodes de temps différentes ne sont pas corrélées entre elles: <span class="math inline">\(Corr(u_t, u_s) = 0 \hspace{0.2cm} \forall \hspace{0.2cm} t \neq s\)</span>. Si cette propriété n’est pas vérifiée, on dit que les erreurs souffrent d’autocorrélation ou de corrélation sérielle car elles sont corrélées dans le temps. L’autocorrélation implique que si à une période <span class="math inline">\(t\)</span> le niveau réel de la variable est pus élevé que la niveau attendu, alors il y a de plus fortes chances que ce soit également le cas dans la période suivante.</p>
<p>Sous les hypothèses TS.4 à TS.5, les erreurs sont dites sphériques. Dans ce cas, la variance des estimateurs MCO est minimale.</p>
<p><strong>Sous les hypothèses TS.1 à TS.5, les estimateurs MCO sont les meilleurs estimateurs linéaires possibles sans biais, conditionnellement à</strong> <span class="math inline">\(X\)</span><strong>.</strong></p>
<ul>
<li><strong>Hypothèse TS.6 : Normalité</strong></li>
</ul>
<p>Les erreurs <span class="math inline">\(u_t\)</span> sont indépendantes de <span class="math inline">\(X\)</span> et indépendamment et identiquement distribuées selon une loi normale <span class="math inline">\((0, \sigma^2)\)</span>. Cette hypothèse implique les hypothèses TS.3, TS.4, TS.5 mais est plus forte de par les hypothèses d’indépendance et de normalité.</p>
<p>Sous les hypothèses TS.1 à TS.6, les estimateurs des MCO sont normalement distribués conditionnellement à <span class="math inline">\(X\)</span>. De plus, sous l’hypothèse nulle, chaque statistique <span class="math inline">\(t\)</span> suit une distribution de Student, et chaque statistique <span class="math inline">\(F\)</span> suit une loi de Fisher.</p>
</section>
<section id="propriétés-asymptotiques-des-mco" class="level2">
<h2 class="anchored" data-anchor-id="propriétés-asymptotiques-des-mco">Propriétés asymptotiques des MCO</h2>
<p>Les hypothèses classiques des MC0 en séries temporelles peuvent être difficiles à remplir. En effet, elles imposent généralement que ces hypothèses soient vérifiées pour toutes les périodes de temps simultanément ce qui est difficile à prouver. Cependant, grâce aux séries dites faiblement dépendantes (stationnaires), nous pouvons assouplir ces hypothèses et utiliser les propriétés asymptotiques des MCO.</p>
<ul>
<li><strong>Hypothèse TS.1’ : Linéarité et faible dépendance</strong></li>
</ul>
<p>Le processus stochastique <span class="math inline">\(\{(x_{t,1}, x_{t,2}, \dots, x_{t,k}, y_t)\}\)</span> : <span class="math inline">\(t=1, 2, \dots, n\)</span> suit un modèle linéaire dans ses paramètres :</p>
<p><span class="math display">\[ y_t = \alpha + \beta_1 X_{1t} + \dots + \beta_k X_{kt} + u_t \]</span></p>
<p>Où <span class="math inline">\(u_t\)</span> correspond à la série des erreurs et <span class="math inline">\(n\)</span> le nombre de périodes temps (observations) de l’échantillon. Ce processus est un processus stationnaire et de faible dépendance. La Loi des Grands Nombres et le Théorème Central Limite s’appliquent aux moyennes de l’échantillon.</p>
<p>La stationnarité de la série n’est pas critique pour les propriétés asymptotiques des MCO (il faut une forme de stabilité dans les temps des relations). La restriction additionnelle majeure de cette hypothèse est l’hypothèse de faible dépendance qui implique que <span class="math inline">\(X_t\)</span> et <span class="math inline">\(X_{t+h}\)</span> sont “presque indépendants” lorsque <span class="math inline">\(h\)</span> augmente.</p>
<ul>
<li><strong>Hypothèse TS.2’ : Absence de parfaite colinéarité</strong></li>
</ul>
<p>Cette hypothèse est la même que l’hypothèse TS.2 :</p>
<p>Dans l’échantillon (et donc dans le processus temporel sous-jacent), aucune variable explicative n’est une constante ou une combinaison linéaire parfaite d’autres variables explicatives.</p>
<p>Cette hypothèse autorise une certaine corrélation entre les variables explicatives tant que celles-ci ne sont pas parfaitement corrélées dans l’échantillon.</p>
<p>Si cette hypothèse n’est pas vérifiée le modèle n’est pas identifiable.</p>
<ul>
<li><strong>Hypothèse TS.3’ : Moyenne conditionnelle nulle</strong></li>
</ul>
<p>Les variables explicatives sont simultanément exogènes : <span class="math inline">\(E(u_t|X_t) = 0\)</span>.</p>
<p>Par stationnarité, on suppose que si l’exogénéité est vérifiée pour une période de temps, cela est vrai aussi pour toutes les périodes de temps. Supprimer la stationnarité nous demanderait de vérifier que la condition est vraie pour tout <span class="math inline">\(t=1, 2, \dots, n\)</span>. Cette hypothèse est bien plus facile à vérifier que l’hypothèse TS.3 qui suppose que le terme d’erreur en <span class="math inline">\(t\)</span> n’est corrélé d’aucune manière que ce soit à toutes les variables explicatives pour toutes les périodes de temps. Ici, il faut simplement vérifier qu’il n’y ait pas de lien quelconque à la période <span class="math inline">\(t\)</span>. Attention cela ne signifie pas que cette hypothèse supprime la possibilité pour que le terme d’erreur contienne des variables retardées. Dans ce cas il faut les prendre en compte dans le modèle.</p>
<p><strong>Sous les hypothèses TS.1’, TS.2’ et TS.3’, les estimateurs MCO sont consistants :</strong> <span class="math inline">\(\text{plim }\hat{\beta} = \beta\)</span><strong>.</strong></p>
<ul>
<li><strong>Hypothèse TS.4’ : Homoscédasticité</strong></li>
</ul>
<p>Les erreurs sont simultanément homoscédastiques : <span class="math inline">\(Var(u_t|X_t) = \sigma^2\)</span></p>
<p>Une foi encore, la stationnarité nous permet de ne vérifier que la relation contemporaine et pas pour toutes les valeurs de temps.</p>
<ul>
<li><strong>Hypothèse TS.5’ : Absence d’autocorrélation</strong></li>
</ul>
<p>Pour tout <span class="math inline">\(t \neq s\)</span>, <span class="math inline">\(E(u_t u_s |X_t X_s) = 0\)</span>. Cette hypothèse signifie simplement que les termes d’erreurs de périodes de temps différentes ne doivent pas être corrélés.</p>
<p><strong>De manière asymptotique (lorsque le nombre d’observation croit vers l’infini), sous les hypothèses TS.1’ à TS.5’, les estimateurs MCO sont asymptotiquement normalement distribués. De plus les écarts-types, t-stat, F-stat et LM-stat issus des MCO sont asymptotiquement valides.</strong></p>
<p>Les modèles ayant des variables explicatives avec tendance peuvent satisfaire les hypothèses TS.1’ à TS.5’ à condition que ces variables soient stationnaires en tendance (processus Trend Stationnary). Aussi longtemps que les tendances sont intégrées dans l’équation si cela est nécessaire, la procédure d’inférence usuelle est asymptotiquement valide.</p>
</section>
<section id="modèles-à-retards-distribués-dl" class="level2">
<h2 class="anchored" data-anchor-id="modèles-à-retards-distribués-dl">Modèles à Retards Distribués (DL)</h2>
<p>Les modèles à retards distribués sont des modèles dynamiques de séries temporelles dans lesquels la dynamique de la variable <span class="math inline">\(Y\)</span> peut être expliquée par des valeurs contemporaines et/ou retardées des variables explicatives <span class="math inline">\(X\)</span>.</p>
<p>Ce type de modèle permet d’incorporer une dynamique plus riche et d’obtenir des effets marginaux (parfois causaux) des variables <span class="math inline">\(X\)</span> sur la variable <span class="math inline">\(Y\)</span>.</p>
<p>Suivant si l’on considère un nombre fini ou infini de valeurs retardées pour la variable explicative, on parlera de modèles à retards distribués finis ou infinis. En pratique seuls les modèles à retards finis peuvent être estimés.</p>
<p>Un modèle à retards distribués finis d’ordre <span class="math inline">\(DL(q_1, \dots, q_k)\)</span> s’écrit sous sa forme générale :</p>
<p><span class="math display">\[
Y_t = \alpha + \sum_{i = 1}^k \sum_{j=0}^{q_j} \beta_{ij} X_{i, t-j} + \varepsilon_t
\]</span></p>
<p>Chaque variable <span class="math inline">\(X\)</span> peut avoir un nombre de retards qui lui est propre afin de capter au mieux la dynamique de la série <span class="math inline">\(Y\)</span>.</p>
<p>Ces modèles souffrent souvent d’une forte multicolinéarité puisque les retards d’une variable <span class="math inline">\(X_{it}\)</span> sont souvent corrélés entre eux, ce qui réduit la précision des estimateurs.</p>
<p>Il est également courant que ce type de modèle n’arrive pas à capter toute la dynamique de la variable dépendante <span class="math inline">\(Y_t\)</span>, à moins d’intégrer de nombreux retards pour chaque variable <span class="math inline">\(X\)</span>. Les résidus restent souvent auto-corrélés rendant la variance des estimateurs non-minimale.</p>
</section>
<section id="multiplicateurs-et-effets-marginaux" class="level2">
<h2 class="anchored" data-anchor-id="multiplicateurs-et-effets-marginaux">Multiplicateurs et effets marginaux</h2>
<section id="dans-un-modèle-statique" class="level3">
<h3 class="anchored" data-anchor-id="dans-un-modèle-statique">Dans un modèle statique</h3>
<p>L’effet marginal d’une variable <span class="math inline">\(X\)</span> sur <span class="math inline">\(Y\)</span> est facilement déterminable dans le cadre d’un modèle statique (toutes les variables sont prises à la même date). Ainsi dans le modèle suivant :</p>
<p><span class="math display">\[ Y_t = \alpha + \beta X_t + \varepsilon_t \]</span></p>
<p>L’effet marginal de <span class="math inline">\(X_t\)</span> sur <span class="math inline">\(Y_t\)</span> (l’impact d’une augmentation d’une unité de <span class="math inline">\(X\)</span> sur <span class="math inline">\(Y\)</span>) est donné par :</p>
<p><span class="math display">\[ \frac{\partial Y_t}{\partial X_t} = \beta \]</span></p>
<p>La réponse de la variable <span class="math inline">\(Y_t\)</span> à un changement d’une unité de la variavle <span class="math inline">\(X_t\)</span> est supposée être immédiate et complète à la fin de la période de mesure.</p>
</section>
<section id="dans-un-modèle-à-retards-distribués" class="level3">
<h3 class="anchored" data-anchor-id="dans-un-modèle-à-retards-distribués">Dans un modèle à retards distribués</h3>
<p>Considérons le modèle à retards distribués d’ordre 2 suivant :</p>
<p><span class="math display">\[
Y_t = \alpha + \beta_0 X_t + \beta_1 X_{t-1} + \beta_2 X_{t-2} + u_t
\]</span></p>
<p>Pour interpréter, les coefficients de cette équation, supposons que <span class="math inline">\(X\)</span> soit constant et égal à <span class="math inline">\(c\)</span> (on se trouve sur une relation d’équilibre). On suppose une augmentation temporaire de <span class="math inline">\(X\)</span> d’une unité à la période <span class="math inline">\(t\)</span>. On a donc :</p>
<p><span class="math display">\[
X_{t-2} = c \hspace{0.2cm}; X_{t-1} = c \hspace{0.2cm}; X_{t} = c +1 \hspace{0.2cm}; X_{t+1} = c \hspace{0.2cm}; X_{t+2} = c
\]</span></p>
<p>Afin de mettre l’accent sur l’effet toute chose égale par ailleurs, on considère que <span class="math inline">\(u_t = 0\)</span>. On a :</p>
<p><span class="math display">\[
\begin{align}
Y_{t-1} &amp;= \alpha + \beta_0 c + \beta_1 c + \beta_2 c \\
Y_t &amp;= \alpha + \beta_0 \left( c+1 \right) + \beta_2 c + \beta_3 c \\
Y_{t+1} &amp;= \alpha + \beta_0 c + \beta_1 \left( c+1 \right) + \beta_3 c \\
Y_{t+2} &amp;= \alpha + \beta_0 c + \beta_1 c + \beta_2 \left( c+1 \right) \\
Y_{t+3} &amp;= \alpha + \beta_0 c + \beta_1 c + \beta_2 c
\end{align}
\]</span></p>
<p>En considérant les deux premières équations, on obtient : <span class="math inline">\(Y_t - Y_{t-1} = \beta_0\)</span> où <span class="math inline">\(\beta_0\)</span> représente le changement immédiat de <span class="math inline">\(Y\)</span> suite à une hausse de l’unité <span class="math inline">\(X\)</span> à la période <span class="math inline">\(t\)</span>, ce que l’on peut noter <span class="math inline">\(\frac{\partial Y_t}{\partial X_t}\)</span> et est communément appelé le multiplicateur de court-terme.</p>
<p>De la même manière <span class="math inline">\(Y_{t+1} - Y_{t-1} = \frac{\partial Y_{t+1}}{\partial X_t} = \beta_1\)</span> et correspond à la variation de <span class="math inline">\(Y\)</span> une période après le changement temporaire de <span class="math inline">\(X\)</span>.</p>
<p><span class="math inline">\(Y_{t+2} - Y_{t-1} = \frac{\partial Y_{t+2}}{\partial X_t} = \beta_2\)</span> correspond à la variation de <span class="math inline">\(Y\)</span> une période après le changement temporaire de <span class="math inline">\(X\)</span>. A la période <span class="math inline">\(t+1\)</span>, <span class="math inline">\(Y\)</span> reprend sa valeur initiale car on a supposé que seuls deux retards de <span class="math inline">\(X\)</span> pouvaient avoir un impact sur <span class="math inline">\(Y\)</span>. Ces multiplicateur sont aussi appelés <em>Delays multipliers</em>.</p>
<p>On peut également s’intéresser au changement de <span class="math inline">\(Y\)</span> à la suite d’une augmentation permanente de <span class="math inline">\(X\)</span>. Considérons que <span class="math inline">\(X\)</span> augmente d’une unité de manière permanente à la période <span class="math inline">\(t\)</span> soit :</p>
<p><span class="math display">\[
X_{t-2} = c \hspace{0.2cm}; X_{t-1} = c \hspace{0.2cm}; X_{t} = c +1 \hspace{0.2cm}; X_{t+1} = c+1 \hspace{0.2cm}; X_{t+2} = c+1
\]</span></p>
<p>On a donc :</p>
<p><span class="math display">\[
\begin{align}Y_{t-1} &amp;= \alpha + \beta_0 c + \beta_1 c + \beta_2 c \\
Y_t &amp;= \alpha + \beta_0 \left( c+1 \right) + \beta_2 c + \beta_3 c \\
Y_{t+1} &amp;= \alpha + \beta_0 \left( c+1 \right) + \beta_1 \left( c+1 \right) + \beta_3 c \\
Y_{t+2} &amp;= \alpha + \beta_0 \left( c+1 \right) + \beta_1 \left( c+1 \right) + \beta_2 \left( c+1 \right)\end{align}
\]</span></p>
<p>A la suite de l’augmentation permanente de <span class="math inline">\(X\)</span>, après une période <span class="math inline">\(Y\)</span> a augmenté de <span class="math inline">\(\beta_0 + \beta_1\)</span>. Après deux périodes, <span class="math inline">\(Y\)</span> a augmenté de <span class="math inline">\(\beta_0 + \beta_1 + \beta_2\)</span>. La somme des coefficients de <span class="math inline">\(X\)</span> et de ses deux retards représente la variation de long-terme de <span class="math inline">\(XY\)</span> suite à un changement permanent de <span class="math inline">\(X\)</span>. On l’appelle le multiplicateur de long-terme. Les valeurs intermédiaires sont appelées <em>Interim multipliers</em>.</p>
</section>
</section>
<section id="modèles-auto-régressifs-à-retards-distribués-ardl" class="level2">
<h2 class="anchored" data-anchor-id="modèles-auto-régressifs-à-retards-distribués-ardl">Modèles Auto-Régressifs à Retards Distribués (ARDL)</h2>
<p>Afin de rendre les modèles plus parcimonieux et essayer de capter la majeure partie de la dynamique de la variable dépendante, il est courant d’introduire une/des valeurs retardées de la variable <span class="math inline">\(Y\)</span> en plus des valeurs retardées des variables <span class="math inline">\(X\)</span>. Cela permet de tenir plus facilement compte du caractère auto-corrélées de la majeure partie des séries temporelles étudiées en économie.</p>
<p>Sous sa forme générale, un <span class="math inline">\(ARDL(p, q_1, \cdots, q_k)\)</span> s’écrit :</p>
<p><span class="math display">\[
Y_t = \alpha + \sum_{l = 1}^p \phi_l Y_{t-l} + \sum_{i = 1}^k \sum_{j=0}^{q_i} \beta_{ij} X_{i, t-j} + \varepsilon_t
\]</span></p>
<p>De manière classique, <span class="math inline">\(\varepsilon_t\)</span> doit être un bruit blanc (non-auto-corrélé et de variance constante).</p>
<p>De la même manière que pour les modèles <span class="math inline">\(ARMA\)</span>, il existe différentes façon (non-exclusives) de déterminer les retards <span class="math inline">\(p\)</span> et <span class="math inline">\(q_i\)</span> d’un modèle <span class="math inline">\(ARDL\)</span> :</p>
<ul>
<li><p>Tester la significativité des paramètres <span class="math inline">\(\phi_p\)</span> et des différents <span class="math inline">\(\beta_{i,q_i} \hspace{0.2cm} \forall \hspace{0.2cm} i = \{1, \dots, k\}\)</span> .</p></li>
<li><p>Utiliser les critères d’informations (AIC, BIC,…) qui vont chercher la spécification qui permet le mieux de reproduire les données en ajoutant une contrainte de parcimonie.</p></li>
<li><p>Utiliser les tests d’autocorrélation des résidus (Ljung-Box) : augmenter l’ordre autorégressif jusqu’à ce que les résidus du modèle soient compatibles avec un bruit blanc.</p></li>
</ul>
<p>Les modèles <span class="math inline">\(ARDL\)</span> peuvent être estimés à partir de la méthode des MCO.</p>
</section>
<section id="cointégration" class="level2">
<h2 class="anchored" data-anchor-id="cointégration">Cointégration</h2>
<p>De manière générale, il n’est pas correct d’utiliser des variables non-stationnaires (caractérisées par un processus <span class="math inline">\(I(1)\)</span>) dans des modèles de régression. En effet, lorsque de telles variables sont utilisées les estimateurs MCO ne sont généralement plus convergent. De plus lorsque deux variables <span class="math inline">\(I(1)\)</span> sont régressées l’une sur l’autre, il a été montré qu’une régression MCO indiquera souvent l’existence d’une relation statistique entre ces deux variables, même lorsqu’elles n’ont aucune raison d’être liées. Il s’agit du problème de <em>corrélation fallacieuse</em>.</p>
<p>Si <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> sont des processus <span class="math inline">\(I(1)\)</span> aucunement liés entre eux, alors la régression suivante est fallacieuse et risque d’indiquer l’existence d’une relation qui n’existe pas :</p>
<p><span class="math display">\[
Y_t = \alpha + \beta X_t + u_t
\]</span></p>
<p>Généralement, pour contrer ce problème, on va stationnariser les variables en les prenant en première différence par exemple. Ainsi le modèle à estimer devient :</p>
<p><span class="math display">\[
\Delta Y_t = \gamma+ \delta\Delta X_t + e_t
\]</span></p>
<p>Avec <span class="math inline">\(\Delta Y_t = Y_t - Y_{t-1}\)</span>. Mais cette régression n’est ps équivalente à la précente. <span class="math inline">\(\gamma\)</span> donne une information bien différente de <span class="math inline">\(\beta\)</span>. La deuxième régression explique la différence de <span class="math inline">\(Y\)</span> en terme de différence de <span class="math inline">\(X\)</span> ce qui n’a rien à voir avec l’explication de <span class="math inline">\(Y\)</span> en fonction de <span class="math inline">\(X\)</span>.</p>
<p>La notion de cointégration introduire par <strong>Engle et Granger (1987)</strong> permet dans certain cas de résoudre ce problème de régression fallacieuse.</p>
<p>En général, si <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> sont des processus <span class="math inline">\(I(1)\)</span>, alors <span class="math inline">\(Y_t - \beta X_t\)</span> sera un processus <span class="math inline">\(I(1)\)</span> pour n’importe quelle valeur de <span class="math inline">\(\beta\)</span>.</p>
<p>Cependant, il est possible que pour une certaine valeur <span class="math inline">\(\beta \neq 0\)</span>, alors <span class="math inline">\(Y_t - \beta X_t\)</span> soit un processus <span class="math inline">\(I(0)\)</span>. Si un tel <span class="math inline">\(\beta\)</span> existe, alors on dira que <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span> sont cointégrés et <span class="math inline">\(\beta\)</span> sera appelé le paramètre de cointégration. Dans ce cas, les deux séries possèdent une relation de long-terme commune. Il peut y avoir des déviations par rapport à cet équilibre de long-terme, mais il existe des forces économiques qui vont ramener les deux variables vers leur relation d’équilibre. La différence entre les deux variables a tendance à revenir vers sa valeur moyenne. Dans ce cas, la régression entre <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> peut se faire sans être fallacieuse.</p>
<p>En revanche, puisque <span class="math inline">\(X_t\)</span> est un processus <span class="math inline">\(I(1)\)</span>, les procédures d’inférence usuelles ne s’appliquent pas nécessairement. De manière analogue aux modèles de régression linéaire, plusieurs hypothèses sont nécessaires à l’obtention d’une distribution normale du paramètre <span class="math inline">\(\beta\)</span> et d’une distribution exacte de la statistique de Student. La plupart peuvent se corriger en augmentant la taille de l’échantillon (normalité des résidus) ou en corrigeant les écarts-types obtenus (sphéricité des erreurs), ce n’est pas le cas pour l’hypothèse d’exogénéité stricte des régresseurs. Cette hypothèse implique dans le cas de séries temporelles fortement persistantes (dont font partis les processus <span class="math inline">\(I(1)\)</span>) que les régresseurs <span class="math inline">\(X\)</span> ne soient liés d’aucune manière que ce soit avec les erreurs pour toutes les périodes de temps possibles. Il s’agit d’une hypothèse extrêmement forte qu’il est difficile de montrer sa validité en pratique.</p>
<p>Pour contrecarrer (en partie) ce problème, il est possible d’inclure <span class="math inline">\(\Delta X_t\)</span> ainsi que d’éventuels retards de cette variable dans l’équation de régression afin de purger la corrélation entre <span class="math inline">\(X\)</span> et <span class="math inline">\(u\)</span>. Dans son cas le plus simple, la régression devient :</p>
<p><span class="math display">\[
Y_t = \alpha + \beta X_t + \Delta X_t + \varepsilon_t
\]</span></p>
<p>Le choix d’inclure ou non des retards additionnels est une question empirique qu’il convient de justifier.</p>
</section>
<section id="modèles-à-correction-derreur" class="level2">
<h2 class="anchored" data-anchor-id="modèles-à-correction-derreur">Modèles à correction d’erreur</h2>
<p>Le concept de cointégration permet également d’enrichir les types de modèles dynamiques à notre disposition. Si <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> sont des processus <span class="math inline">\(I(1)\)</span> non-cointégrés, alors la modélisation doit être une modélisation en différence première (généralement). Considérons le modèle ARDL suivant :</p>
<p><span class="math display">\[
\Delta Y_t = \alpha + \phi \Delta Y_{t-1} + \gamma_0 \Delta X_t + \gamma_1 \Delta X_{t-1} + u_t
\]</span></p>
<p>Dans le cas où <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> sont cointégrés, nous disposons de variables supplémentaires que l’on peut inclure dans cette équation. En effet dans ce cas : <span class="math inline">\(Y_t - \beta X_t\)</span> est un processus <span class="math inline">\(I(0)\)</span>, et ses retards peuvent sans problèmes être inclus dans une régression. L’équation devient donc :</p>
<p><span class="math display">\[
\begin{align}
\Delta Y_t &amp;= \alpha + \phi \Delta Y_{t-1} + \gamma_0 \Delta X_t + \gamma_1 \Delta X_{t-1} + \delta (Y_{t-1} - \beta X_{t-1}) + u_t \\
\Leftrightarrow \Delta Y_t &amp;= \alpha + \phi \Delta Y_{t-1} + \gamma_0 \Delta X_t + \gamma_1 \Delta X_{t-1} + \delta \text{ECT} + u_t
\end{align}
\]</span></p>
<p>Le terme <span class="math inline">\((Y_{t-1} - \beta X_{t-1})\)</span> est appelé le terme à correcteur d’erreur (<em>Error Correction Term</em>), et ce type de modélisation est appelée Modèle à Correction d’Erreur.</p>
<p>Ce type de modèles permet d’étudier la dynamique de court terme dans la relation entre <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span>. Si <span class="math inline">\(\delta &lt; 0\)</span> et si <span class="math inline">\(Y_{t-1} &gt; \beta X_{t-1}\)</span>, alors <span class="math inline">\(Y\)</span> a dépassé l’équilibre durant la période précédente. Puisque <span class="math inline">\(\delta &lt; 0\)</span>, le terme à correction d’erreur fait en sorte que <span class="math inline">\(Y\)</span> est ramené vers l’équilibre en diminuant. A l’inverse, si <span class="math inline">\(Y_{t-1} &lt; \beta X_{t-1}\)</span>, alors <span class="math inline">\(Y\)</span> était inférieur à la valeur d’équilibre à la période précédente. Dans ce cas, le terme à correction d’erreur induit une variation positive de <span class="math inline">\(Y\)</span> vers l’équilibre.</p>
<p>Le temps que mettent les séries à revenir à leur équilibre est donné par <span class="math inline">\(\frac{1}{\delta}\)</span>.</p>
</section>
<section id="procédure-dengle-granger" class="level2">
<h2 class="anchored" data-anchor-id="procédure-dengle-granger">Procédure d’Engle-Granger</h2>
<p>La procédure d’Engle-Granger est une procédure en deux étapes pour estimer des modèles à correction d’erreur. Attention la procédure présentée ici n’est valide que pour deux séries toutes les deux caractérisées par un processus <span class="math inline">\(I(1)\)</span>.</p>
<section id="ère-étape-tester-lexistence-de-la-cointégration" class="level3">
<h3 class="anchored" data-anchor-id="ère-étape-tester-lexistence-de-la-cointégration">1ère étape : Tester l’existence de la cointégration</h3>
<p>Dans un premier temps, si les séries <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span> sont des processus <span class="math inline">\(I(1)\)</span>, alors il convient de régresser <span class="math inline">\(Y\)</span> sur <span class="math inline">\(X\)</span> :</p>
<p><span class="math display">\[
Y_t = \alpha + \beta X_t + e_t
\]</span></p>
<p>On récupère ensuite la série des résidus <span class="math inline">\(\hat{e}_t\)</span> et l’on teste la stationnarité de cette série. Généralement on utilise le test ADF avec un modèle sans constante mais avec ou sans tendance. On estime la relation :</p>
<p><span class="math display">\[
\Delta \hat{e}_t = \phi \hat{e}_{t-1} + \sum_{i=1}^p \phi_i \Delta \hat{e}_{t-i} + u_t
\]</span></p>
<p>avec <span class="math inline">\(\hat{e}_t = \hat{Y}_t - \hat{\alpha} - \hat{\beta}X_t\)</span>. On teste ensuite :</p>
<p><span class="math display">\[
\left\{    
\begin{array}{ll}       
H_0 : \phi = 0 \text{ ; } \hat{e}_t \text{ non stationnaire}  \\       
H_1 : \phi &lt; 0 \text{ ; } \hat{e}_t \text{ stationnaire}     
\end{array}
\right.
\]</span></p>
<p>Avec la statistique de test :</p>
<p><span class="math display">\[
t_{\hat{\phi}} = \frac{\hat{\phi}}{\hat{\sigma}_{\hat{\phi}}}
\]</span></p>
<p>Attention, les valeurs critiques pour tester la stationnarité de cette série sont différentes de celles utilisées classiquement.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Type de test</th>
<th style="text-align: center;">1%</th>
<th style="text-align: center;">5%</th>
<th style="text-align: center;">10%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Sans tendance</td>
<td style="text-align: center;">-3.90</td>
<td style="text-align: center;">-3.34</td>
<td style="text-align: center;">-3.04</td>
</tr>
<tr class="even">
<td style="text-align: center;">Avec tendance</td>
<td style="text-align: center;">-4.32</td>
<td style="text-align: center;">-3.78</td>
<td style="text-align: center;">-3.50</td>
</tr>
</tbody>
</table>
<p>La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(t_{\hat{\phi}} &lt; t\)</span> : on rejette l’hypothèse nulle. Les résidus sont stationnaires. Les séries <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> sont cointégrées.</p></li>
<li><p>Si <span class="math inline">\(t_{\hat{\phi}} &gt; t\)</span> : on ne peut pas rejeter la l’hypothèse nulle. Les résidus ne sont pas stationnaires. Les séries <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> ne sont pas cointégrées.</p></li>
</ul>
</section>
<section id="ème-étape-estimer-le-modèle-à-correction-derreur" class="level3">
<h3 class="anchored" data-anchor-id="ème-étape-estimer-le-modèle-à-correction-derreur">2ème étape : Estimer le modèle à correction d’erreur</h3>
<p>Si <span class="math inline">\(\hat{e}_t\)</span> est bien un processus <span class="math inline">\(I(0)\)</span>, alors les séries <span class="math inline">\(Y_t\)</span> et <span class="math inline">\(X_t\)</span> sont cointégrées et caractérisées par une relation de long terme. La régression de l’une l’autre n’est plus une régression fallacieuse. On peut donc estimer le modèle en niveau (en incluant <span class="math inline">\(\Delta X_t\)</span> et ses retards et/ou ses valeurs avancées ainsi que les retards de <span class="math inline">\(Y_t\)</span> si besoin) et obtenir les coefficients de long-terme de la série.</p>
<p>On peut ensuite estimer le modèle à correction d’erreur dans lequel le terme à correction d’erreur correspond à la série des résidus <span class="math inline">\(\hat{e}_t\)</span> :</p>
<p><span class="math display">\[
\Delta Y_t = \alpha + \phi \Delta Y_{t-1} + \gamma_0 \Delta X_t + \gamma_1 \Delta X_{t-1} + \delta \hat{e}_{t-1} + u_t
\]</span></p>
<p>Ce modèle nous permet d’obtenir des effets de court-terme avec les coefficients des variables en différence, ainsi que la vitesse d’ajustement des séries suite à un écart à leur relation de long-terme.</p>
</section>
</section>
<section id="extension-de-la-cointégration" class="level2">
<h2 class="anchored" data-anchor-id="extension-de-la-cointégration">Extension de la cointégration</h2>
<p>La cointégration à la Granger peut évidemment être généralisée avec un nombre de variables supérieures à 2. Mais cette méthode requiert tout de même que l’ensemble des variables soient intégrées du même ordre. <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/jae.616?casa_token=PNv1tRySyY0AAAAA%3A871E331d0NLVpRpeJ4TghehXlefBXEznk49q2vbrkuWUMKenTGGqaPc_rK95X3aWp34rPcw8leVRkog"><strong>Pesaran et al (2001)</strong></a> ont développé une méthodologie permettant de tester l’existence d’une relation entre les niveaux de <span class="math inline">\(K\)</span> variables que celles-ci soient intégrées d’ordre 1 et/ou d’ordre 0.</p>
<p>La méthodologie repose sur l’estimation de 3 modèles :</p>
<section id="modèle-ardl-général" class="level3">
<h3 class="anchored" data-anchor-id="modèle-ardl-général">Modèle ARDL général</h3>
<p>La forme générale d’un <span class="math inline">\(ARDL(p, q_1, \dots, q_k)\)</span> est donnée par :</p>
<p><span class="math display">\[
Y_t = c_0 + c_1t + \sum_{i=1}^pb_{y,i}Y_{t-i} + \sum_{j=1}^k \sum_{l=0}^{q_j}b_{j,l}X_{j,t-l} + \varepsilon_t
\]</span></p>
<p>Ce modèle régresse la variable <span class="math inline">\(Y_t\)</span> sur une constante <span class="math inline">\(c_0\)</span>, une possible tendance linéaire <span class="math inline">\(c_1\)</span>, ses <span class="math inline">\(p\)</span> valeurs passées ainsi que les valeurs contemporaines et passées des variables <span class="math inline">\(X_t\)</span>. Le choix des ordres <span class="math inline">\(p, q_1, \dots, q_j\)</span> est une question empirique.</p>
<p>Les multiplicateurs de court-terme sont donnés par les coefficients associés aux valeurs contemporaines des variables <span class="math inline">\(X_{j,t}\)</span>. ces multiplicateurs indiquent la réponse de <span class="math inline">\(Y_t\)</span> suite à une variation temporaire d’une unité de <span class="math inline">\(X_{j,t}\)</span>.</p>
<p><span class="math display">\[
\text{SR}_{\text{ARDL}} = \frac{\partial Y_t}{\partial X_{j,t}} = b_{j,0} \hspace{0.3cm} j \in \left\{ 1, \cdots, k \right\}
\]</span></p>
<p>Les multiplicateurs <span class="math inline">\(\text{Delay}_{x_{j,s}}\)</span> indiquent la réponse de la variable <span class="math inline">\(Y_{t+s}\)</span> suite à une variation temporaire de la variable <span class="math inline">\(X_{j,t}\)</span>. Il s’agit d’une réponse directe. Il s’agit du coefficient associé au <span class="math inline">\(s^{\text{ième}}\)</span> retard de la variable <span class="math inline">\(X_{j}\)</span> auquel viennent s’ajouter les effets directs sur les périodes antérieures pondérées par les effet auto-régressifs de la variable <span class="math inline">\(Y\)</span>.</p>
<p><span class="math display">\[
\text{Delay}_{x_{j,s}} = \frac{\partial Y_{t+s}}{\partial X_{j,t}} = b_{j,s} + \sum_{i=1}^{min \left\{ p,s \right\}} b_{y,i} \frac{\partial Y_{t+\left( s-i \right)}}{\partial X_{j,t}} \hspace{0.6cm} ; \hspace{0.3cm} b_{j,s} = 0 \hspace{0.3cm} \forall \hspace{0.3cm} s&gt;q
\]</span></p>
<p>Les multiplicateurs <span class="math inline">\(\text{Interim}_{x_{j,s}}\)</span> indiquent la réponse de la variable <span class="math inline">\(Y_{t+s}\)</span> suite à une variation permanente de la variable <span class="math inline">\(X_{j,t}\)</span>. Il s’agit de la somme des multiplicateurs <span class="math inline">\(\text{Delay}_{x_{j,i}}\)</span> avec <span class="math inline">\(i = \{1, \dots, s\}\)</span>.</p>
<p><span class="math display">\[
\text{Interim}_{x_{j,s}} = \sum_{i=0}^s \text{Delay}_{x_{j,s}}
\]</span></p>
<p>Les multiplicateurs de long-terme indiquent la réponse totale de la variable <span class="math inline">\(Y\)</span> suite à un choc permanent sur la variable <span class="math inline">\(X_{j,t}\)</span>. Il s’agit de la somme des coefficients associés à la variable <span class="math inline">\(X_t\)</span> et à ses retards divisé par 1 moins la somme des coefficients auto-régressifs de la variable <span class="math inline">\(Y\)</span>.</p>
<p><span class="math display">\[
\text{LR}_{\text{ARDL}} = \frac{\partial Y_{t+\infty}}{\partial X_{j,t}} = \theta_j = \frac{\sum_{l=0}^{q_j} b_{j,l}}{1 - \sum_{i=1}^p b_{y,i}} \hspace{0.6cm} ; \hspace{0.3cm} j  \in  \left\{ 1, \cdots, k \right\}
\]</span></p>
<p>Le vecteur de coefficients <span class="math inline">\(\hat{\theta}_j\)</span> permet de construire l’équation de long-terme associé aux niveaux des variables :</p>
<p><span class="math display">\[
\hat{Y}_t^{\text{LT}} = \hat{\alpha} + \sum_{j=1}^k \hat{\theta}_j X_{j,t}
\]</span></p>
</section>
<section id="modèle-unrestricted-error-correction-model-uecm" class="level3">
<h3 class="anchored" data-anchor-id="modèle-unrestricted-error-correction-model-uecm">Modèle Unrestricted Error Correction Model (UECM)</h3>
<p>La formule d’un modèle UECM dérivé du modèle ARDL précédent est la suivante :</p>
<p><span class="math display">\[
\Delta Y_t = c_0 + c_1t + \pi_y Y_{t-1} + \sum_{j=1}^k \pi_j X_{j,t-1} + \sum_{i=1}^{p-1}\psi_{y,i} \Delta Y_{t-i} + \sum_{j=1}^k \sum_{l=1}^{q_j - 1} \psi_{j,l} \Delta X_{j,t-l} + \sum_{j=1}^k \omega_j \Delta X_{j,t} + \varepsilon_t
\]</span></p>
<p>Ce modèle met en relation la première différence de la variable <span class="math inline">\(Y_t\)</span> avec les retards de sa première différence ainsi que les retards de la première différence des variables <span class="math inline">\(X_t\)</span> comme un <span class="math inline">\(ARDL\)</span> classique avec des variables en première différence. Les coefficients associés à ces variables en différences premières représentes la relation de court-terme entre <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span>. Cependant le modèle UECM va également inclure les niveaux des variable <span class="math inline">\(Y\)</span> et <span class="math inline">\(X_j\)</span> retardés d’une période afin d’inclure les relations de long-terme entre les variables.</p>
<p>A partir de ce modèle il est possible de calculer les multiplicateurs de court-terme et de long-terme. Ces multiplicateurs sont strictement égaux aux multiplicateurs calculés à partir du modèle <span class="math inline">\(ARDL\)</span> en niveaux.</p>
<p>Les multiplicateurs de court-terme sont donnés par les coefficients associés aux valeurs contemporaines des premières différences de <span class="math inline">\(X_j\)</span>.</p>
<p><span class="math display">\[
\text{SR}_{\text{UECM}} = \text{SR}_{\text{ARDL}} = \frac{\partial Y_t}{\partial X_{j,t}} = \omega_j \hspace{0.6cm} j \in \left\{ 1, \cdots, k \right\}
\]</span></p>
<p>Les multiplicateurs de long-terme sont donnés par la division du coefficient associé à la variable <span class="math inline">\(X_{j,t}\)</span> en niveau avec le coefficient associé à <span class="math inline">\(Y_t\)</span> en niveau multiplié par moins 1.</p>
<p><span class="math display">\[
\text{LR}_{\text{UECM}} = \text{LR}_{\text{ARDL}} = \frac{\partial Y_{t+\infty}}{\partial X_{j,t}} = \theta_j = \frac{\pi_j}{-\pi_y} \hspace{0.6cm} j \in \left\{ 1, \cdots, k \right\}
\]</span></p>
<p>De la même manière que pour le modèle <span class="math inline">\(ARDL\)</span>, le vecteur de coefficient de long-terme <span class="math inline">\(\hat{\theta}_j\)</span> peut être utilisé pour construire l’équation de long-terme des variables en niveau :</p>
<p><span class="math display">\[
\hat{Y}_t^{\text{LT}} = \hat{\alpha} + \sum_{j=1}^k \hat{\theta}_j X_{j,t}
\]</span></p>
<p>Ce modèle apporte une précision supplémentaire par rapport au modèle <span class="math inline">\(ARDL\)</span> puisqu’il indique également la vitesse de convergence des séries suite à un écart à la relation d’équilibre à travers le coefficient <span class="math inline">\(\pi_y\)</span>. En effet, si <span class="math inline">\(Y_{t-1}\)</span> augmente de 1 tandis que toutes les variables restent inchangées, cela signifie que <span class="math inline">\(Y_{t-1}\)</span> s’est écarté de sa valeur de long-terme. Le coefficient <span class="math inline">\(\pi_y\)</span> indique la force de rappel qui va ramener <span class="math inline">\(Y_t\)</span> vers sa valeur de long-terme. <span class="math inline">\(\frac{1}{\pi_y}\)</span> indique le temps nécessaire pour <span class="math inline">\(Y\)</span> retourne à sa valeur de long-terme suite à un déséquilibre.</p>
</section>
<section id="modèle-restricted-error-correction-model-recm" class="level3">
<h3 class="anchored" data-anchor-id="modèle-restricted-error-correction-model-recm">Modèle Restricted Error Correction Model (RECM)</h3>
<p>A partir du modèle <span class="math inline">\(ARDL\)</span> il est également possible de construire une modélisation <span class="math inline">\(RECM\)</span> de la forme suivante :</p>
<p><span class="math display">\[
\Delta Y_t = c_0 + c_1t + \sum_{i=1}^{p-1} \psi_{y,i} \Delta Y_{t-i} + \sum_{j=1}^k \sum_{l=1}^{q_{j-1}} \Delta X_{j, t-l} + \sum_{j=1}^k \omega_j \Delta X_{j,t} + \pi_y \text{ECT}_t = \varepsilon_t
\]</span></p>
<p>Ce modèle relie la première différence de la variable <span class="math inline">\(Y\)</span> avec les premières différences (retardées) des variable <span class="math inline">\(X_j\)</span>. La différence avec le modèle UECM réside dans le fait que les variables en niveau ont été retirées et inclues dans le terme <span class="math inline">\(\text{ECT}_t\)</span>. cela permet de gagner des degrés de liberté puisqu’il y a moins de coefficients à estimer. On augmente donc la précision de nos estimateurs en diminuant leur variance estimée. Il permet également d’obtenir plus de flexibilité concernant l’inclusion de tendance ou de constante (voir plus loin).</p>
<p>Il faut remarquer que ce modèle permet d’obtenir les même coefficients de court-terme que les modèles <span class="math inline">\(ARDL\)</span> et <span class="math inline">\(UECM\)</span> à partir des coefficients <span class="math inline">\(\omega_j\)</span>. La force de rappel donnée par le coefficient <span class="math inline">\(\pi_j\)</span> est également la même que dans le modèle <span class="math inline">\(UECM\)</span>.</p>
<p>Lors de la construction de ce modèle, 5 cas sont possibles (et vont conditionner les tests statistiques) :</p>
<ul>
<li><strong>Cas 1 : Sans constante ni tendance dans les équation de court- et long-terme</strong></li>
</ul>
<p>Dans ce cas, on va contrainte qu’il n’y ait ni tendance ni constante à la fois dans l’équation en différence et dans le terme à correction d’erreur. On a donc :</p>
<p><span class="math display">\[
\begin{align}
&amp;c_0 = c_1 = 0 \\
\\
&amp;\text{ECT}_t = Y_{t-1} - \left( \sum_{j=1}^k \theta_j X_{j, t-1} \right)
\end{align}
\]</span></p>
<p>Le terme à correction d’erreur en <span class="math inline">\(t\)</span> est donné la différence entre la valeur de <span class="math inline">\(Y_{t-1}\)</span> et sa valeur de long-terme en <span class="math inline">\(t-1\)</span> (sans constante ni tendance) calculée à partir des multiplicateurs de long-terme <span class="math inline">\(\theta_j\)</span>. Il s’agit de la valeur du déséquilibre de <span class="math inline">\(Y\)</span> avec sa valeur de long-terme.</p>
<ul>
<li><strong>Cas 2 : Sans tendance ni constante dans l’équation de court-terme ; sans tendance mais avec constante dans l’équation de long-terme</strong></li>
</ul>
<p>Dans ce cas, on va contraindre à ce qu’il n’y ait ni constante ni tendance dans l’équation en différence, mais on va inclure une constante dans le terme à correction d’erreur. On a donc :</p>
<p><span class="math display">\[
\begin{align}
&amp;c_0 = c_1 = 0 \\
\\
&amp;\text{ECT}_t = Y_{t-1} - \left( \mu + \sum_{j=1}^k \theta_j X_{j, t-1} \right)
\end{align}
\]</span></p>
<ul>
<li><strong>Cas 3 : Sans tendance mais avec constante dans l’équation de court-terme ; sans tendance et sans constante dans l’équation de long-terme</strong></li>
</ul>
<p>Dans ce cas, on va contraire à ce qu’il y ait une constante mais pas de tendance dans l’équation en différence. On ne va inclure ni tendance ni constante dans le terme à correction d’erreur. On a donc :</p>
<p><span class="math display">\[
\begin{align}
&amp;c_1 = 0 \\
\\
&amp;\text{ECT}_t = Y_{t-1} - \left( \sum_{j=1}^k \theta_j X_{j, t-1} \right)
\end{align}
\]</span></p>
<ul>
<li><strong>Cas 4 : Sans tendance mais avec constante dans l’équation de court-terme ; sans constante et avec tendance dans l’équation de long-terme</strong></li>
</ul>
<p>Dans ce cas, on va contraindre à ce qu’il y ait une constante mais pas de tendance dans l’équation en différence. On va inclure une tendance linéaire dans le terme à correction d’erreur mais pas de constante. On a donc :</p>
<p><span class="math display">\[
\begin{align}
&amp;c_1 = 0 \\
\\
&amp;\text{ECT}_t = Y_{t-1} - \left( \delta(t-1) + \sum_{j=1}^k \theta_j X_{j, t-1} \right)
\end{align}
\]</span></p>
<ul>
<li><strong>Cas 5 : Avec tendance et constante dans l’équation de court-terme ; Sans tendance ni constante dans l’équation de long-terme</strong></li>
</ul>
<p>Dans ce cas, on va contraindre à ce qu’il y ait une constante et une tendance dans l’équation en différence et à ce qu’il n’y ait ni constante ni tendance dans le terme à correction d’erreur. On a donc :</p>
<p><span class="math display">\[
\text{ECT}_t = Y_{t-1} - \left( \sum_{j=1}^k \theta_j X_{j, t-1} \right)
\]</span> Il faut bien noter que tous ces cas ne sont pas tous utilisables pour une même modélisation. En effet, on ne peut pas imposer une contrainte (ou une absence de contrainte) sur des paramètres qui n’ont pas été inclus dans le modèle <span class="math inline">\(ARDL\)</span> ou <span class="math inline">\(UECM\)</span> sous-jacent. Par exemple, si le modèle <span class="math inline">\(ARDL\)</span> n’inclue pas de tendance linéaire, il n’est pas possible d’utiliser les cas où on impose une tendance linéaire dans l’équation de court- ou long-terme puisque cette tendance n’existe pas dans le modélisation initiale.</p>
</section>
<section id="bound-f-test-bound-t-test" class="level3">
<h3 class="anchored" data-anchor-id="bound-f-test-bound-t-test">Bound F test / Bound t test</h3>
<p>Les tests initiaux de cointégration ne fonctionnent généralement que si toutes les variables sont intégrées du même ordre ce qui dans un certain nombre de cas pratiques n’est pas réaliste. <strong>Pesaran et al (2001)</strong> ont développé deux tests statistique afin de tester s’il existe une relation de long-terme entre les variables en niveau et ce même si toutes les variables ne sont intégrées du même ordre.</p>
<p>Les valeurs critiques de ces tests ne sont pas standards. <strong>Pesaran et al (2001)</strong> ont tabulés des valeurs critiques lorsque toutes les variables sont intégrées d’ordre 0 et lorsque toutes les variables sont intégrées d’ordre 1. Cela donne un intervalle permettant de déterminer si un ensemble de variables <span class="math inline">\(I(0)\)</span> et <span class="math inline">\(I(1)\)</span> possèdent une relation de long-terme ou non.</p>
<p>Le premier test est un test de Wald (sorte d’équivalent au test de Fisher) qui va tester les coefficients associés aux variables en niveau sont tous conjointement différents de 0.</p>
<p>Ainsi à partir du modèle :</p>
<p><span class="math display">\[
\Delta Y_t = c_0 + c_1t + \pi_y Y_{t-1} + \sum_{j=1}^k \pi_j X_{j,t-1} + \sum_{i=1}^{p-1}\psi_{y,i} \Delta Y_{t-i} + \sum_{j=1}^k \sum_{l=1}^{q_j - 1} \psi_{j,l} \Delta X_{j,t-l} + \sum_{j=1}^k \omega_j \Delta X_{j,t} + \varepsilon_t
\]</span></p>
<p>On va tester (en fonction du cas de modèle <span class="math inline">\(RECM\)</span> choisi) :</p>
<ul>
<li><strong>Cas 1, 3, 5</strong></li>
</ul>
<p><span class="math display">\[
\left\{    
\begin{array}{ll}       
H_0 : \pi_y = \pi_1 = \dots = \pi_k = 0  \\       
H_1 : \pi_y \neq \pi_1 \neq \dots \neq \pi_k \neq 0     
\end{array}
\right.
\]</span></p>
<ul>
<li><strong>Cas 2 :</strong></li>
</ul>
<p><span class="math display">\[
\left\{    
\begin{array}{ll}       
H_0 : \pi_y = \pi_1 = \dots = \pi_k = c_0 = 0  \\       
H_1 : \pi_y \neq \pi_1 \neq \dots \neq \pi_k \neq c_0 \neq 0     
\end{array}
\right.
\]</span></p>
<ul>
<li><strong>Cas 4</strong></li>
</ul>
<p><span class="math display">\[
\left\{    
\begin{array}{ll}       
H_0 : \pi_y = \pi_1 = \dots = \pi_k = c_1 = 0  \\       
H_1 : \pi_y \neq \pi_1 \neq \dots \neq \pi_k \neq c_1 \neq 0     
\end{array}
\right.
\]</span></p>
<p>Sous l’hypothèse nulle, ne présentent pas de relation de long-terme en niveau. Elles ne sont pas cointégrées. On estime donc un <span class="math inline">\(ARDL\)</span> en première différence classique. Sous l’hypothèse alternative, il existe une relation de long-terme entre les variables en niveau. On peut donc estimer un modèle à correction d’erreur.</p>
<p>Une fois la statistique de test obtenue (non reportée ici) notée <span class="math inline">\(F\)</span>, il faut la comparer aux valeurs critiques tabulés notées <span class="math inline">\(F_{I(0)}\)</span> pour la valeur critique obtenue lorsque toutes les variables sont <span class="math inline">\(I(0)\)</span> et <span class="math inline">\(F_{I(1)}\)</span> pour la valeur critique obtenue lorsque toutes les variables sont <span class="math inline">\(I(1)\)</span>. Cela donne l’intervalle : <span class="math inline">\([F_{I(0)} \hspace{0.2cm}; \hspace{0.2cm} F_{I(1)}]\)</span>. La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(F &lt; F_{I(0)}\)</span> alors on ne peut pas rejeter <span class="math inline">\(H_0\)</span>. Il semblerait qu’il n’existe pas de relation en niveau entre les variables peu importe que les variables soient toutes <span class="math inline">\(I(0)\)</span>, <span class="math inline">\(I(1)\)</span> ou mutuellement cointégrées.</p></li>
<li><p>Si <span class="math inline">\(F &gt; F_{I(1)}\)</span>} alors on peut rejeter l’hypothèse nulle. Il semblerait qu’il existe une relation en niveau entre les variables peu importe quelles soient toutes <span class="math inline">\(I(0)\)</span>, <span class="math inline">\(I(1)\)</span> ou mutuellement cointégrées</p></li>
<li><p>Si <span class="math inline">\(F \in [F_{I(0)} \hspace{0.2cm}; \hspace{0.2cm} F_{I(1)}]\)</span> alors on ne peut pas tirer de conclusion à partir de ce test. Il faut regarder variable par variables leur ordre d’intégration avant de faire des tests d’inférence.</p></li>
</ul>
<p>Le deuxième test proposé par <strong>Pesaran et al (2001)</strong> est un dérivé du test de Student qui va tester si la force de rappel de long-terme est significativement différente de 0 dans un modèle <span class="math inline">\(UECM\)</span>.</p>
<p>Ainsi à partir du modèle :</p>
<p><span class="math display">\[
\Delta Y_t = c_0 + c_1t + \pi_y Y_{t-1} + \sum_{j=1}^k \pi_j X_{j,t-1} + \sum_{i=1}^{p-1}\psi_{y,i} \Delta Y_{t-i} + \sum_{j=1}^k \sum_{l=1}^{q_j - 1} \psi_{j,l} \Delta X_{j,t-l} + \sum_{j=1}^k \omega_j \Delta X_{j,t} + \varepsilon_t
\]</span></p>
<p>On va tester :</p>
<p><span class="math display">\[
\left\{    
\begin{array}{ll}       
H_0 : \pi_y = 0  \\       
H_1 : \pi_y  \neq 0     
\end{array}
\right.
\]</span></p>
<p>Une fois la statistique de test obtenue (non reportée ici) notée <span class="math inline">\(t\)</span>, il faut la comparer aux valeurs critiques tabulés notées <span class="math inline">\(t_{I(0)}\)</span> pour la valeur critique obtenue lorsque toutes les variables sont <span class="math inline">\(I(0)\)</span> et <span class="math inline">\(t_{I(1)}\)</span> pour la valeur critique obtenue lorsque toutes les variables sont <span class="math inline">\(I(1)\)</span>. Cela donne l’intervalle : <span class="math inline">\([t_{I(0)} \hspace{0.2cm}; \hspace{0.2cm} t_{I(1)}]\)</span>. La règle de décision est la suivante :</p>
<ul>
<li><p>Si <span class="math inline">\(t &lt; t_{I(0)}\)</span> alors on ne peut pas rejeter <span class="math inline">\(H_0\)</span>. Il semblerait qu’il n’existe pas de force de rappel de long-terme. Ce qui semblerait indiquer l’absence de relation en niveau entre les variables peu importe que les variables soient toutes <span class="math inline">\(I(0)\)</span>, <span class="math inline">\(I(1)\)</span> ou mutuellement cointégrées.</p></li>
<li><p>Si <span class="math inline">\(t &gt; t_{I(1)}\)</span>} alors on peut rejeter l’hypothèse nulle. Il semblerait qu’il existe une force de rappel de long-terme. Ce qui semblerait indiquer la présence de relation en niveau entre les variables peu importe quelles soient toutes <span class="math inline">\(I(0)\)</span>, <span class="math inline">\(I(1)\)</span> ou mutuellement cointégrées</p></li>
<li><p>Si <span class="math inline">\(t \in [t_{I(0)} \hspace{0.2cm}; \hspace{0.2cm} t_{I(1)}]\)</span> alors on ne peut pas tirer de conclusion à partir de ce test. Il faut regarder variable par variables leur ordre d’intégration avant de faire des tests d’inférence.</p></li>
</ul>
</section>
</section>
</section>
<section id="code" class="level1">
<h1>Code</h1>
<section id="setup" class="level2">
<h2 class="anchored" data-anchor-id="setup">Setup</h2>
<p>Charger les librairies et tous les objets de setup. Comme rien n’est chargé pour l’instant il faut :</p>
<ul>
<li><p>Utiliser la syntaxe <code>here::here()</code> pour dire que l’on utilise la fonction <code>here()</code> du package <code>here</code></p></li>
<li><p>Indiquer le chemin en entier jusqu’au script <code>setup.R</code></p></li>
</ul>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécute le script setup.R pour charger tous les éléments importants</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"02-codes"</span>, <span class="st">"utils"</span>, <span class="st">"setup.R"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="présentation-des-données" class="level2">
<h2 class="anchored" data-anchor-id="présentation-des-données">Présentation des données</h2>
<p>Nous voulons modéliser la monnaie réelle (agrégat M2) en fonction du revenu réel, du taux d’intérêt des obligations étatiques et du taux d’intérêt des dépôts bancaires au Danemark de 1974:Q1 à 1987:Q3.</p>
<p>Commençons par charger les données contenues dans l’objet <code>ARDL::denmark</code> et transformons le en objet de classe <code>tibble</code> pour plus de facilités à manipuler les données. (Si certaines fonctions imposent l’utilisation d’un objet TS, alors on le retransformera en temps voulu).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualiser à quoi ressemble l'objet denmark et l'enregister dans l'objet df_ts</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>df_ts <span class="ot">&lt;-</span> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ARDL<span class="sc">::</span>denmark</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>df_ts <span class="sc">|&gt;</span> <span class="fu">head</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>             LRM      LRY        LPY       IBO    IDE
1974 Q1 11.63255 5.903658 -0.6187359 0.1547356 0.0940
1974 Q2 11.60415 5.873820 -0.5807479 0.1779912 0.0955
1974 Q3 11.58152 5.837818 -0.5428478 0.1705647 0.0955
1974 Q4 11.60185 5.812255 -0.5046041 0.1522273 0.0955
1975 Q1 11.58630 5.803945 -0.4864585 0.1342276 0.0885
1975 Q2 11.60450 5.786761 -0.4544386 0.1334805 0.0790</code></pre>
</div>
</div>
<p>Il s’agit d’un objet de classe TS (Time Series) contenant 5 colonnes pour les différentes variables. Les dates sont indiquées en tantque noms des lignes. On peut vouloir transformer ce objet Time Series en un tibble afin d’avoir plus de facilité à manipuler les données ou pour les représenter graphiquement. Pour cela, le package <code>timetk</code> propose la fonction <code>tk_tbl()</code> pour transformer un objetv Time Series en tibble facilement, en conservant l’unité de temps si on le souhaite.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  df_ts <span class="sc">|&gt;</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  timetk<span class="sc">::</span><span class="fu">tk_tbl</span>(</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">rename_index =</span> <span class="st">"date"</span> <span class="co"># Rename the time variable "date"</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 55 × 6
   date        LRM   LRY    LPY   IBO    IDE
   &lt;yearqtr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
 1 1974 Q1    11.6  5.90 -0.619 0.155 0.094 
 2 1974 Q2    11.6  5.87 -0.581 0.178 0.0955
 3 1974 Q3    11.6  5.84 -0.543 0.171 0.0955
 4 1974 Q4    11.6  5.81 -0.505 0.152 0.0955
 5 1975 Q1    11.6  5.80 -0.486 0.134 0.0885
 6 1975 Q2    11.6  5.79 -0.454 0.133 0.079 
 7 1975 Q3    11.7  5.83 -0.441 0.128 0.076 
 8 1975 Q4    11.8  5.93 -0.439 0.129 0.074 
 9 1976 Q1    11.8  5.94 -0.404 0.141 0.072 
10 1976 Q2    11.8  5.94 -0.373 0.153 0.078 
# ℹ 45 more rows</code></pre>
</div>
</div>
<p>L’index temporel a bien été ajouté dans la variable “date” sous un format <code>yearqtr</code> indiquant un format trimestriel. Avec cette tibble on peut facilement utiliser le package <code>ggplot2</code> pour représenter graphiquement nos séries. Afin de toutes les mettre dans un seul graphique facilement, on va pivoter les données afin que toutes les valeurs soient dans une seule colonne et que le nom des variables soit dans une autre colonne.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">|&gt;</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Regrouper toutes les valeurs des variables d'intérêt dans une variable nommée "value" et le nom des variables associées dans une variable nommée "variable"</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">cols =</span> <span class="sc">!</span><span class="fu">c</span>(date),</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">names_to =</span> <span class="st">"variable"</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">values_to =</span> <span class="st">"value"</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>() <span class="sc">|&gt;</span> </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Faire un graphique en ligne</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> value)) <span class="sc">+</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Séparer les variables dans différents panels avec chaque axe qui leur est propre</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="st">"variable"</span>, <span class="at">scales =</span> <span class="st">"free"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 275 × 3
   date      variable   value
   &lt;yearqtr&gt; &lt;chr&gt;      &lt;dbl&gt;
 1 1974 Q1   LRM      11.6   
 2 1974 Q1   LRY       5.90  
 3 1974 Q1   LPY      -0.619 
 4 1974 Q1   IBO       0.155 
 5 1974 Q1   IDE       0.094 
 6 1974 Q2   LRM      11.6   
 7 1974 Q2   LRY       5.87  
 8 1974 Q2   LPY      -0.581 
 9 1974 Q2   IBO       0.178 
10 1974 Q2   IDE       0.0955
# ℹ 265 more rows</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="04-ARDL-cointegration_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>On peut aussi tout simplement utiliser la fonction <code>plot()</code> sur l’objet time series, mais les possibilités de customisation sont plus faibles.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Avec un objet TS</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(ARDL<span class="sc">::</span>denmark)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="04-ARDL-cointegration_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Il semblerait que les variables ne soient pas stationnaires. On peut le vérifier avec le test ADF par exemple. On va effectuer le test ADF sur chaque série. Pour éviter d’avoir à le faire manuellement pour chaque série, on peut faire une boucle <code>for</code> qui va nous permettre de boucler une opération sur un certain nombre d’éléments.</p>
<p>On peut cependant être plus efficace en utilisant le package <code>purrr</code>. La fonction <code>map()</code> permet d’appliquer une fonction sur chaque élément d’un vecteur ou d’une liste donné. Ainsi <code>map(x, f)</code> va appliquer la fonction <code>f</code> à chaque élément contenu dans <code>x</code>. La fonction <code>map2(x, y, f)</code> permet de faire la même chose sauf qu’il y a deux vecteurs simultanés <code>x</code> et <code>y</code> qui vont rentrer dans la fonction <code>f</code>. De base ces fonctions renvoient une liste. La fonction <code>map2_dfr()</code> permet simplement de rendre un tibble au lieu d’une liste.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># N'exécuter que si le package "dobby" est installé</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Appliquer le test ADF sur chaque série (on peut utiliser l'objet tibble ou bien l'objet TS sans distinction)</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># La fonction a besoin de 2 élements : la série et son nom</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  purrr<span class="sc">::</span><span class="fu">map2_dfr</span>(</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">list</span>(df<span class="sc">$</span>LRM, df<span class="sc">$</span>LRY, df<span class="sc">$</span>IBO, df<span class="sc">$</span>IDE), <span class="co"># Série à tester</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">c</span>(<span class="st">"LRM"</span>, <span class="st">"LRY"</span>, <span class="st">"IBO"</span>, <span class="st">"IDE"</span>), <span class="co"># Nom de la série</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Créer une fonction prenant deux paramètres : série et name</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cette fonction exécuter la fonction adf_test_auto</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    \(serie, name) dobby<span class="sc">::</span><span class="fu">adf_test_auto</span>(</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      serie, name, </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      <span class="at">lags =</span> <span class="dv">20</span>, </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">message =</span> <span class="cn">FALSE</span>, </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      <span class="at">return_res =</span> <span class="cn">TRUE</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">"Le package 'dobby' n'est pas installé."</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4 × 6
  serie_name nb_lags model has_ur phi_stat phi_crit
  &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
1 LRM             10 2     FALSE     -3.04    -2.89
2 LRY             18 3     TRUE      -3.27    -3.45
3 IBO              1 3     TRUE      -3.00    -3.45
4 IDE              1 3     FALSE     -3.85    -3.45</code></pre>
</div>
</div>
<p>Les tests ADF nous indiquent que les séries LRY et IBO ne semblent pas stationnaires. Leur inclusion dans un modèle utilisant les MCO peut résulter en une corrélation fallacieuse. Les coefficients associés ont de très fortes chances d’être biaisés fortement. Si le package <code>dobby</code> n’est pas installé, le test ADF peut se faire manuellement avec la fonction <code>urca::ur.df()</code>. Attention, les p.values indiquées ne sont pas les bonnes, et les valeurs critiques données par la fonction concernent le test joint ADF et pas le test individuel (que l’on préfère généralement).</p>
</section>
<section id="régression-statique" class="level2">
<h2 class="anchored" data-anchor-id="régression-statique">Régression statique</h2>
<p>Dans un premier temps, modélison la relation (possiblement fallacieuse) suivante :</p>
<p><span class="math display">\[
\text{LRM}_t = \alpha + \beta_1 \text{LRY}_t + \beta_2 \text{IBO}_t + \beta_3 \text{IDE}_t +u_t
\]</span></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Régression statique</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">lm</span>(LRM <span class="sc">~</span> LRY <span class="sc">+</span> IBO <span class="sc">+</span> IDE, <span class="at">data =</span> df))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = LRM ~ LRY + IBO + IDE, data = df)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.093657 -0.028844  0.005755  0.030319  0.107622 

Coefficients:
            Estimate Std. Error t value             Pr(&gt;|t|)    
(Intercept)  4.39447    0.58112   7.562       0.000000000707 ***
LRY          1.29580    0.09398  13.788 &lt; 0.0000000000000002 ***
IBO         -2.61631    0.32819  -7.972       0.000000000161 ***
IDE          0.61856    0.69110   0.895                0.375    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.04259 on 51 degrees of freedom
Multiple R-squared:  0.9262,    Adjusted R-squared:  0.9218 
F-statistic: 213.3 on 3 and 51 DF,  p-value: &lt; 0.00000000000000022</code></pre>
</div>
</div>
<p>A partir du modèle statique, on peut voir que les variables LRY et IBO sont très fortement significatives et que le R² ajusté est de 0,9218 ce qui est extrêmement élevé et un signe de corrélation fallacieuse/de coefficients biaisés à cause de la non stationnarité.</p>
<p>Un moyen simple de prendre en compte la non stationnarité consiste à différencier les variables non-stationnaires avant de les inclure dans le modèle de régression. Pour cela on peut soit créer des variables dans le tibble <code>df</code>, soit on peut utiliser la fonction <code>dynlm::dynlm()</code> qui permet d’appliquer des opérateurs de séries temporelles.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Différencier les variables LRY et IBO</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>df_diff <span class="ot">&lt;-</span> </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  df <span class="sc">|&gt;</span> </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Modifier le dataframe df</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Effectuer la même opération pour les variable sélectionnées</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">across</span>(</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">.cols =</span> <span class="fu">c</span>(LRY, IBO), <span class="co"># Sélectionner les variables LRY et IBO</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">.fns =</span> \(variable) variable <span class="sc">-</span> <span class="fu">lag</span>(variable), <span class="co"># Leur appliquer une fonction qui va faire la différence première</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>      <span class="at">.names =</span> <span class="st">"diff_{.col}"</span> <span class="co"># Créer une nouvelle variable qui va prendre le nom diff_ suivi du nom originel de la variable</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Afficher le résultat</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 55 × 8
   date        LRM   LRY    LPY   IBO    IDE diff_LRY  diff_IBO
   &lt;yearqtr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
 1 1974 Q1    11.6  5.90 -0.619 0.155 0.094  NA       NA       
 2 1974 Q2    11.6  5.87 -0.581 0.178 0.0955 -0.0298   0.0233  
 3 1974 Q3    11.6  5.84 -0.543 0.171 0.0955 -0.0360  -0.00743 
 4 1974 Q4    11.6  5.81 -0.505 0.152 0.0955 -0.0256  -0.0183  
 5 1975 Q1    11.6  5.80 -0.486 0.134 0.0885 -0.00831 -0.0180  
 6 1975 Q2    11.6  5.79 -0.454 0.133 0.079  -0.0172  -0.000747
 7 1975 Q3    11.7  5.83 -0.441 0.128 0.076   0.0467  -0.00507 
 8 1975 Q4    11.8  5.93 -0.439 0.129 0.074   0.0964   0.000422
 9 1976 Q1    11.8  5.94 -0.404 0.141 0.072   0.00781  0.0125  
10 1976 Q2    11.8  5.94 -0.373 0.153 0.078  -0.00232  0.0118  
# ℹ 45 more rows</code></pre>
</div>
</div>
<p>Le modèle estimé devient :</p>
<p><span class="math display">\[
\text{LRM}_t = \alpha + \beta_1 \Delta \text{LRY}_t + \beta_2 \Delta \text{IBO}_t + \beta_3 \text{IDE}_t +u_t
\]</span></p>
<p>Avec <span class="math inline">\(\Delta X_t = X_t - X_{t-1}\)</span>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Régression statique avec toutes les variables I(0)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>reg_statique <span class="ot">&lt;-</span> </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lm</span>(LRM <span class="sc">~</span> diff_LRY <span class="sc">+</span> diff_IBO <span class="sc">+</span> IDE, <span class="at">data =</span> df_diff) <span class="sc">|&gt;</span> </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>() <span class="sc">|&gt;</span> </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = LRM ~ diff_LRY + diff_IBO + IDE, data = df_diff)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.241490 -0.084574  0.001314  0.078514  0.198113 

Coefficients:
            Estimate Std. Error t value             Pr(&gt;|t|)    
(Intercept)  12.4140     0.1110 111.888 &lt; 0.0000000000000002 ***
diff_LRY     -0.3442     0.6791  -0.507                0.614    
diff_IBO      0.2766     1.5898   0.174                0.863    
IDE          -7.2621     1.2090  -6.007          0.000000214 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.1179 on 50 degrees of freedom
  (1 observation effacée parce que manquante)
Multiple R-squared:  0.4388,    Adjusted R-squared:  0.4051 
F-statistic: 13.03 on 3 and 50 DF,  p-value: 0.00000208</code></pre>
</div>
</div>
<p>On peut obtenir le même résultat en passant directement des opérateurs de série temporelle à la fonction <code>dynlm()</code>. L’opérateur <code>d(x,i)</code> permet d’appliquer une différence d’ordre <span class="math inline">\(i\)</span> à la variable <span class="math inline">\(x_t\)</span>. <span class="math inline">\(d(x, 1) = x_t - x_{t-1}\)</span> ; <span class="math inline">\(d(x, 2) = x_t - x_{t-2}\)</span>. Pour utiliser ces opérateurs temporels, il faut absolument passer comme argument des données de type TS (ou autre format de séries temporelles).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Utiliser des opérateurs de séries temporelles directement</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>dynlm<span class="sc">::</span><span class="fu">dynlm</span>(</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  LRM <span class="sc">~</span> <span class="fu">d</span>(LRY) <span class="sc">+</span> <span class="fu">d</span>(IBO) <span class="sc">+</span> IDE, <span class="co"># d() -&gt; fait la différence première d'une série </span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> df_ts <span class="co"># Obligé de transformer le dataframe en objet Time Series pour faire la différenciation</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "zooreg" data:
Start = 1974 Q2, End = 1987 Q3

Call:
dynlm::dynlm(formula = LRM ~ d(LRY) + d(IBO) + IDE, data = df_ts)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.241490 -0.084574  0.001314  0.078514  0.198113 

Coefficients:
            Estimate Std. Error t value             Pr(&gt;|t|)    
(Intercept)  12.4140     0.1110 111.888 &lt; 0.0000000000000002 ***
d(LRY)       -0.3442     0.6791  -0.507                0.614    
d(IBO)        0.2766     1.5898   0.174                0.863    
IDE          -7.2621     1.2090  -6.007          0.000000214 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.1179 on 50 degrees of freedom
Multiple R-squared:  0.4388,    Adjusted R-squared:  0.4051 
F-statistic: 13.03 on 3 and 50 DF,  p-value: 0.00000208</code></pre>
</div>
</div>
<p>On peut voir (les deux méthodes donnant strictement le même résultat) que les variables en premières différences ne sont plus significatives tandis que la variable IDE devient significative. L’augmentation des taux d’intérêts bancaire fait diminuer fortement l’offre totale de monnaie M2 puisqu’il y a moins de crédits en circulation dans l’économie.</p>
<p>Un des point gros point d’attention lorsque l’on travaille avec des séries temporelles est le fait de savoir si toute l’autocorrélation des séries a bien été prise en compte. Sinon cela retire la propriété de variance minimale des estimateurs et nous indique également que notre modélisation est incomplète et n’arrive pas à correctement reproduire les caractéristique de notre série d’origine.</p>
<p>On utilise donc le test de Ljung-Box sur notre série des résidus.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># N'exécuter que si le package dobby est installé</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(reg_statique<span class="sc">$</span>residuals, <span class="st">"résidus statiques"</span>, <span class="at">test_type =</span> <span class="st">"Box-Pierce"</span>, <span class="at">return_output =</span> <span class="cn">FALSE</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">"Le package 'dobby' n'est pas installé"</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>

#########################################
# Box-Pierce test for résidus statiques #
#########################################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'résidus statiques' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Pierce test

data:  serie
X-squared = 40.611, df = 1, p-value = 0.0000000001858


[[2]]

    Box-Pierce test

data:  serie
X-squared = 115.88, df = 20, p-value = 0.000000000000001665</code></pre>
</div>
</div>
<p>On peut voir que nos résidus sont fortement autocorrélés. Cela n’est pas surprenant puisque nous n’avons inclue aucune dynamique dans notre régression. Notre modélisation est donc incomplète.</p>
</section>
<section id="régression-avec-variable-dépendante-retardée" class="level2">
<h2 class="anchored" data-anchor-id="régression-avec-variable-dépendante-retardée">Régression avec variable dépendante retardée</h2>
<p>Pour prendre en compte plus de dynamique, on peut rajouter des retards dans les variables explicatives ou bien ajouter des retards de la variable dépendante. Pour ce faire, on peut soit créer les variables dans un dataframe, soit on utilise la fonction <code>dynlm()</code>. L’opérateur <code>L(x,i)</code> permet d’indiquer que l’on prend la variable <span class="math inline">\(x\)</span> retardée de <span class="math inline">\(i\)</span> périodes. <span class="math inline">\(L(x,2) = x_{t-2}\)</span>.</p>
<p>Le modèle estimé devient :</p>
<p><span class="math display">\[
\text{LRM}_t = \alpha + \beta_0 \text{LRM}_{t-1} + \beta_1 \Delta \text{LRY}_t + \beta_2 \Delta \text{IBO}_t + \beta_3 \text{IDE}_t +u_t
\]</span></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Régression avec variable dépendante retardée</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>reg_dep_retard <span class="ot">&lt;-</span> </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  dynlm<span class="sc">::</span><span class="fu">dynlm</span>(</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  LRM <span class="sc">~</span> <span class="fu">L</span>(LRM) <span class="sc">+</span> <span class="fu">d</span>(LRY) <span class="sc">+</span> <span class="fu">d</span>(IBO) <span class="sc">+</span> IDE,</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> df_ts</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>() <span class="sc">|&gt;</span> </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "zooreg" data:
Start = 1974 Q2, End = 1987 Q3

Call:
dynlm::dynlm(formula = LRM ~ L(LRM) + d(LRY) + d(IBO) + IDE, 
    data = df_ts)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.051689 -0.019407  0.003597  0.014714  0.089534 

Coefficients:
            Estimate Std. Error t value             Pr(&gt;|t|)    
(Intercept)  0.51046    0.39511   1.292              0.20243    
L(LRM)       0.96244    0.03188  30.189 &lt; 0.0000000000000002 ***
d(LRY)       0.49018    0.15740   3.114              0.00308 ** 
d(IBO)      -1.02792    0.36532  -2.814              0.00703 ** 
IDE         -0.70936    0.35101  -2.021              0.04877 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0269 on 49 degrees of freedom
Multiple R-squared:  0.9714,    Adjusted R-squared:  0.969 
F-statistic: 415.5 on 4 and 49 DF,  p-value: &lt; 0.00000000000000022</code></pre>
</div>
</div>
<p>On peut re-tester l’autocorrélation des résidus de notre modèle.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># N'exécuter que si le package 'dobby' est installé</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(reg_dep_retard<span class="sc">$</span>residuals, <span class="st">"résidus dépendante retardée"</span>, <span class="at">test_type =</span> <span class="st">"Box-Pierce"</span>, <span class="at">return_output =</span> <span class="cn">FALSE</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">"Le package 'dobby' n'est pas installé"</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>

###################################################
# Box-Pierce test for résidus dépendante retardée #
###################################################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'résidus dépendante retardée' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Pierce test

data:  serie
X-squared = 4.9261, df = 1, p-value = 0.02645


[[2]]

    Box-Pierce test

data:  serie
X-squared = 111.38, df = 20, p-value = 0.00000000000001099</code></pre>
</div>
</div>
<p>Outre le R² ajusté très élevé qui est suspect, on peut voir que l’inclusion de la variable dépendante retardée permet de prendre en compte d’avantage d’autocorrélation à l’ordre 1. En revanche on modélise très mal l’autocorrélation de long-terme. Il s’agit d’un indice indiquant que l’on n’a pas pris en compte assez de retards dans notre modélisation (ou qu’il nous manque des variables explicatives).</p>
</section>
<section id="modélisation-ardl" class="level2">
<h2 class="anchored" data-anchor-id="modélisation-ardl">Modélisation ARDL</h2>
<p>La fonction <code>dynlm()</code> est très puissante mais sa syntaxe peut vite devenir encombrante lorsque les retards et les différences s’enchaînent. Le package <code>ARDL</code> permet d’obtenir les mêmes résultats mais avec une syntaxe bien moins volumineuse. On peut utiliser la même syntaxe que pour la fonction <code>dynlm()</code> mais au lieu d’avoir à indiquer chaque retard pour chaque variable, on indique simplement le nombre de retards que l’on souhaite inclure dans la modélisation pour chaque variable via le paramètre <code>order</code>.</p>
<p>On peut passer comme argument de données un tibble ou un objet de séries temporelles. Certaines fonctionnalités vont marcher avec un type d’objet et pas l’autre. Par exemple la création et représentation de l’équation de long-terme nécessite un objet de Série Temporelle pour fonctionner correctement. On va donc choisir d’utiliser un objet de série temporelle dès qu’on le peut.</p>
<p>Le package <code>timetk</code> permet encore une fois de facilement passer d’un tibble à un objet TS avec la fonction <code>tk_ts()</code>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformer df_diff en objet de Série temporelle</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>df_diff_ts <span class="ot">&lt;-</span> </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  df_diff <span class="sc">|&gt;</span> </span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  timetk<span class="sc">::</span><span class="fu">tk_ts</span>(</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">select =</span> <span class="sc">!</span>date, <span class="co"># La variable date doit être retirée</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">start =</span> <span class="fu">min</span>(df_diff<span class="sc">$</span>date), <span class="co"># On indique que notre série temporelle commence à la première date</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">frequency =</span> <span class="dv">4</span> <span class="co"># On indique que l'on se trouve avec des données trimestrielles : 4 périodes par années</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Afficher les premières observations</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>df_diff_ts <span class="sc">|&gt;</span> </span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>             LRM      LRY        LPY       IBO    IDE     diff_LRY   diff_IBO
1974 Q1 11.63255 5.903658 -0.6187359 0.1547356 0.0940           NA         NA
1974 Q2 11.60415 5.873820 -0.5807479 0.1779912 0.0955 -0.029838489  0.0232556
1974 Q3 11.58152 5.837818 -0.5428478 0.1705647 0.0955 -0.036002387 -0.0074265
1974 Q4 11.60185 5.812255 -0.5046041 0.1522273 0.0955 -0.025562871 -0.0183374
1975 Q1 11.58630 5.803945 -0.4864585 0.1342276 0.0885 -0.008309338 -0.0179997
1975 Q2 11.60450 5.786761 -0.4544386 0.1334805 0.0790 -0.017184230 -0.0007471</code></pre>
</div>
</div>
<p>On va maintenant utiliser le package <code>ARDL</code> pour modéliser notre série LRM avec une variable dépendante retardée.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modélisation avec variable dépendante retardée</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">ardl</span>(</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  LRM <span class="sc">~</span> diff_LRY <span class="sc">+</span> diff_IBO <span class="sc">+</span> IDE, <span class="co"># variables à utiliser</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> df_diff_ts, <span class="co"># Dataframe ou objet TS</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) <span class="co"># Nombre de retards à inclure pour chaque variable. La première est la variable dépendante</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "ts" data:
Start = 1974(2), End = 1987(3)

Call:
dynlm::dynlm(formula = full_formula, data = data, start = start, 
    end = end)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.051689 -0.019407  0.003597  0.014714  0.089534 

Coefficients:
            Estimate Std. Error t value             Pr(&gt;|t|)    
(Intercept)  0.51046    0.39511   1.292              0.20243    
L(LRM, 1)    0.96244    0.03188  30.189 &lt; 0.0000000000000002 ***
diff_LRY     0.49018    0.15740   3.114              0.00308 ** 
diff_IBO    -1.02792    0.36532  -2.814              0.00703 ** 
IDE         -0.70936    0.35101  -2.021              0.04877 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0269 on 49 degrees of freedom
Multiple R-squared:  0.9714,    Adjusted R-squared:  0.969 
F-statistic: 415.5 on 4 and 49 DF,  p-value: &lt; 0.00000000000000022</code></pre>
</div>
</div>
<p>On peut ajouter facilement de nouveaux retards sur nos variables. Ici nous allons estimer un <span class="math inline">\(ARDL(1, 2, 3, 1)\)</span> pour l’exemple.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ajouter des retards aux variables explicatives</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">ardl</span>(</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  LRM <span class="sc">~</span> diff_LRY <span class="sc">+</span> diff_IBO <span class="sc">+</span> IDE, <span class="co"># variables à utiliser</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> df_diff_ts, <span class="co"># Dataframe ou objet TS</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">order =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>) <span class="co"># Nombre de retards à inclure</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "ts" data:
Start = 1975(1), End = 1987(3)

Call:
dynlm::dynlm(formula = full_formula, data = data, start = start, 
    end = end)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.044614 -0.017754  0.000147  0.012726  0.088022 

Coefficients:
               Estimate Std. Error t value            Pr(&gt;|t|)    
(Intercept)     0.30516    0.46579   0.655              0.5161    
L(LRM, 1)       0.97689    0.03713  26.312 &lt;0.0000000000000002 ***
diff_LRY        0.37523    0.17916   2.094              0.0426 *  
L(diff_LRY, 1)  0.05537    0.17872   0.310              0.7583    
L(diff_LRY, 2)  0.06658    0.17738   0.375              0.7094    
diff_IBO       -1.06777    0.50307  -2.123              0.0400 *  
L(diff_IBO, 1) -0.16443    0.57978  -0.284              0.7782    
L(diff_IBO, 2) -0.22506    0.48442  -0.465              0.6447    
L(diff_IBO, 3) -0.86968    0.44042  -1.975              0.0552 .  
IDE            -0.52856    0.74500  -0.709              0.4821    
L(IDE, 1)       0.20189    0.75753   0.267              0.7912    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.02749 on 40 degrees of freedom
  (1 observation effacée parce que manquante)
Multiple R-squared:  0.9738,    Adjusted R-squared:  0.9673 
F-statistic: 148.9 on 10 and 40 DF,  p-value: &lt; 0.00000000000000022</code></pre>
</div>
</div>
</section>
<section id="procédure-de-pesaran-et-al-2001" class="level2">
<h2 class="anchored" data-anchor-id="procédure-de-pesaran-et-al-2001">Procédure de Pesaran et al (2001)</h2>
<p>Comme nous l’avons vu, notre jeu de données est caractérisé par des variables <span class="math inline">\(I(0)\)</span> stationnaires et des variables <span class="math inline">\(I(1)\)</span> non-stationnaires. Cette disparité empêche d’utiliser la procédure d’Engle et Granger pour tester la cointégration de nos variables. Actuellement, on ne sait pas s’il existe une relation entre les niveaux de nos variables et s’il est donc correct de modéliser nos séries selon une telle relation ou selon un modèle à correction d’erreur. La meilleure chose que l’on pouvait faire était donc de différencier nos variables <span class="math inline">\(I(1)\)</span> afin d’obtenir des variables <span class="math inline">\(I(0)\)</span> et les inclure dans la modélisation.</p>
<p>Cependant, cela est limitant car ce qui nous intéresse est le niveau des taux d’intérêts et pas leur taux de croissance. Pour pallier ce problème, on peut utiliser la méthode de Pesaran et al (2001) afin de tester s’il existe une relation entre les niveaux de nos variables ou non.</p>
<section id="estimation-de-lardl-en-niveau" class="level3">
<h3 class="anchored" data-anchor-id="estimation-de-lardl-en-niveau">Estimation de l’ARDL en niveau</h3>
<p>La première étape consiste à trouver et estimer le meilleur ARDL entre les niveaux de nos variables. Pour cela, on peut tester différentes spécifications, utiliser les tests sur les résidus ou bien utiliser les critères d’information. La fonction <code>ARDL::auto.ardl()</code> permet de trouver le meilleur ARDL en fonction du critère d’information choisi.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester "tous" les modèles et les classer en fonction de leur AIC </span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>models <span class="ot">&lt;-</span> </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  ARDL<span class="sc">::</span><span class="fu">auto_ardl</span>(</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    LRM <span class="sc">~</span> LRY <span class="sc">+</span> IBO <span class="sc">+</span> IDE, <span class="co"># Variables à utiliser</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> df_ts, <span class="co"># Source des variables</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">max_order =</span> <span class="dv">5</span>, <span class="co"># Nombre de retards maximum autorisé pour les variables</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">selection =</span> <span class="st">"AIC"</span> <span class="co"># critère d'information à utiliser</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Afficher le classement des modèles</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>models<span class="sc">$</span>top_orders <span class="sc">|&gt;</span> </span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>   LRM LRY IBO IDE       AIC
1    3   1   3   2 -251.0259
2    3   1   3   3 -250.1144
3    2   2   0   0 -249.6266
4    3   2   3   2 -249.1087
5    3   2   3   3 -248.1858
6    2   2   0   1 -247.7786
7    2   1   0   0 -247.5643
8    2   2   1   1 -246.6885
9    3   3   3   3 -246.3061
10   2   2   1   2 -246.2709
11   2   1   1   1 -245.8736
12   2   2   2   2 -245.7722
13   1   1   0   0 -245.6620
14   2   1   2   2 -245.1712
15   3   1   2   2 -245.0996
16   1   0   0   0 -244.4317
17   1   1   0   1 -243.7702
18   5   5   5   5 -243.3120
19   4   1   3   2 -243.0728
20   4   1   3   3 -242.4378</code></pre>
</div>
</div>
<p>On peut voir que le modèle ARDL qui minimise le critère AIC (pondération entre l’explication du modèle et le nombre de paramètres à estimer) est le modèle <span class="math inline">\(ARDL(3,1,3,2)\)</span>. Le modèle avec simplement un retard sur la variable retardée est le modèle numéro 16.</p>
<p>Ces modèles étant déjà estimés, on peut obtenir les résultats associés :</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Enregistrer le meilleur modèle dans une variables</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>ardl_3132 <span class="ot">&lt;-</span> models<span class="sc">$</span>best_model</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Afficher le résumé des résultats</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>ardl_3132 <span class="sc">|&gt;</span> </span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "zooreg" data:
Start = 1974 Q4, End = 1987 Q3

Call:
dynlm::dynlm(formula = full_formula, data = data, start = start, 
    end = end)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.029939 -0.008856 -0.002562  0.008190  0.072577 

Coefficients:
            Estimate Std. Error t value   Pr(&gt;|t|)    
(Intercept)   2.6202     0.5678   4.615 0.00004187 ***
L(LRM, 1)     0.3192     0.1367   2.336   0.024735 *  
L(LRM, 2)     0.5326     0.1324   4.024   0.000255 ***
L(LRM, 3)    -0.2687     0.1021  -2.631   0.012143 *  
LRY           0.6728     0.1312   5.129 0.00000832 ***
L(LRY, 1)    -0.2574     0.1472  -1.749   0.088146 .  
IBO          -1.0785     0.3217  -3.353   0.001790 ** 
L(IBO, 1)    -0.1062     0.5858  -0.181   0.857081    
L(IBO, 2)     0.2877     0.5691   0.505   0.616067    
L(IBO, 3)    -0.9947     0.3925  -2.534   0.015401 *  
IDE           0.1255     0.5545   0.226   0.822161    
L(IDE, 1)    -0.3280     0.7213  -0.455   0.651847    
L(IDE, 2)     1.4079     0.5520   2.550   0.014803 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0191 on 39 degrees of freedom
Multiple R-squared:  0.988, Adjusted R-squared:  0.9843 
F-statistic: 266.8 on 12 and 39 DF,  p-value: &lt; 0.00000000000000022</code></pre>
</div>
</div>
</section>
<section id="tester-la-sphéricité-des-erreurs" class="level3">
<h3 class="anchored" data-anchor-id="tester-la-sphéricité-des-erreurs">Tester la sphéricité des erreurs</h3>
<p>On peut, tout comme un modèle linéaire en coupe transversale, tester si les erreurs sont sphériques. Pour rappel, en série temporelle, les erreurs sont dites sphériques si leur variance est constante et si elles ne sont pas autocorrélées dans le temps. On peut utiliser les tests de Breush-Pagan et de White pour tester si la variance des résidus est constante.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Breusch-Pagan test</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>lmtest<span class="sc">::</span><span class="fu">bptest</span>(ardl_3132)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    studentized Breusch-Pagan test

data:  ardl_3132
BP = 4.4815, df = 12, p-value = 0.9731</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># White test</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>whitestrap<span class="sc">::</span><span class="fu">white_test</span>(ardl_3132)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>White's test results

Null hypothesis: Homoskedasticity of the residuals
Alternative hypothesis: Heteroskedasticity of the residuals
Test Statistic: 2.91
P-value: 0.23393</code></pre>
</div>
</div>
<p>Il semblerait que l’on ne puisse pas rejeter l’hypothèse nulle d’homoscédasticité à partir de ces tests. On peut également tester pour la présence d’effets ARCH, c’est à dire de variance conditionnellement hétéroscédastique avec le test ARCH.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>fDMA<span class="sc">::</span><span class="fu">archtest</span>(<span class="fu">as.numeric</span>(ardl_3132<span class="sc">$</span>residuals<span class="sc">**</span><span class="dv">2</span>), <span class="at">lag =</span> <span class="dv">20</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Engle's LM ARCH Test

data:  as.numeric(ardl_3132$residuals^2)
statistic = 7.1133, lag = 20, p-value = 0.9963
alternative hypothesis: ARCH effects of order 20 are present</code></pre>
</div>
</div>
<p>Une fois de plus, on ne peut pas rejeter l’hypothèse nulle d’homoscédasticité conditionnelle. Il semblerait que nos résidus aient une variance constante.</p>
<p>Pour tester l’autocorrélation, on peut utiliser les tests de Ljung-Box ou Box-Pierce sur la série des résidus. Une fonction “wrap-up” est présente dans le package <code>dobby</code>. Dans le cas où celui-ci ne fonctionne pas (pour des raisons d’installation), on peut utiliser la fonction <code>stats::Box.test()</code> qui est la fonction utilisée par le package <code>dobby</code>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># N'exécuter que si le package dobby est installé</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (rlang<span class="sc">::</span><span class="fu">is_installed</span>(<span class="st">"dobby"</span>)) {</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Ljung-Box test for lags 1 and 20 with dobby package</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  dobby<span class="sc">::</span><span class="fu">check_univariate_autocorr</span>(ardl_3132<span class="sc">$</span>residuals, <span class="st">"résidus ARDL(3132)"</span>, <span class="at">return_output =</span> <span class="cn">FALSE</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">"Le package 'dobby' n'est pas installé"</span>)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stderr">
<pre><code>

#########################################
# Ljung-Box test for résidus ARDL(3132) #
#########################################</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>H0 : There is no autocorrelation in 'résidus ARDL(3132)' for a given lag number</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]

    Box-Ljung test

data:  serie
X-squared = 0.33598, df = 1, p-value = 0.5622


[[2]]

    Box-Ljung test

data:  serie
X-squared = 25.026, df = 20, p-value = 0.2004</code></pre>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ljung-Box test for lag 1</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>stats<span class="sc">::</span><span class="fu">Box.test</span>(ardl_3132<span class="sc">$</span>residuals, <span class="at">lag =</span> <span class="dv">1</span>, <span class="at">type =</span> <span class="st">"Ljung-Box"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Box-Ljung test

data:  ardl_3132$residuals
X-squared = 0.33598, df = 1, p-value = 0.5622</code></pre>
</div>
</div>
<p>On ne peut pas rejeter l’hypothèse nulle de non-autocorrélation des résidus. Il semblerait que nos erreurs soient sphériques. La variance de nos estimateurs devrait donc être minimale. Il semblerait également que l’on ait correctement réussi à prendre en compte la dynamique de notre variable dépendante.</p>
</section>
<section id="corriger-lhétéroscédasticité" class="level3">
<h3 class="anchored" data-anchor-id="corriger-lhétéroscédasticité">Corriger l’hétéroscédasticité</h3>
<p>Si jamais on soupçonne la non-sphéricité des erreurs d’être un problème, on peut utiliser des écarts-types robustes à l’hétéroscédasticité et/ou l’autocorrélation.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ecrats-types robustes à l'hétéroscédasticité à la White</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>ardl_3132 <span class="sc">|&gt;</span> </span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  lmtest<span class="sc">::</span><span class="fu">coeftest</span>(<span class="at">vcov. =</span> car<span class="sc">::</span>hccm)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
t test of coefficients:

            Estimate Std. Error t value   Pr(&gt;|t|)    
(Intercept)  2.62019    0.55620  4.7108 0.00003105 ***
L(LRM, 1)    0.31921    0.11064  2.8851  0.0063441 ** 
L(LRM, 2)    0.53261    0.15949  3.3395  0.0018565 ** 
L(LRM, 3)   -0.26867    0.13907 -1.9319  0.0606633 .  
LRY          0.67280    0.18559  3.6252  0.0008244 ***
L(LRY, 1)   -0.25742    0.14648 -1.7573  0.0867088 .  
IBO         -1.07852    0.29746 -3.6257  0.0008233 ***
L(IBO, 1)   -0.10620    0.57722 -0.1840  0.8549824    
L(IBO, 2)    0.28767    0.44060  0.6529  0.5176456    
L(IBO, 3)   -0.99468    0.48237 -2.0621  0.0459079 *  
IDE          0.12546    0.53451  0.2347  0.8156488    
L(IDE, 1)   -0.32798    0.69532 -0.4717  0.6397674    
L(IDE, 2)    1.40786    0.56042  2.5122  0.0162470 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ecarts-types robustes à l'hétéroscédasticité et l'autocorrélation à la Newey-West</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>ardl_3132 <span class="sc">|&gt;</span> </span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  lmtest<span class="sc">::</span><span class="fu">coeftest</span>(<span class="at">vcov. =</span> sandwich<span class="sc">::</span>vcovHAC)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
t test of coefficients:

             Estimate Std. Error t value     Pr(&gt;|t|)    
(Intercept)  2.620192   0.428058  6.1211 0.0000003516 ***
L(LRM, 1)    0.319208   0.093305  3.4211    0.0014764 ** 
L(LRM, 2)    0.532606   0.141237  3.7710    0.0005395 ***
L(LRM, 3)   -0.268666   0.130453 -2.0595    0.0461676 *  
LRY          0.672799   0.148197  4.5399 0.0000528383 ***
L(LRY, 1)   -0.257419   0.112267 -2.2929    0.0273290 *  
IBO         -1.078518   0.256202 -4.2096    0.0001456 ***
L(IBO, 1)   -0.106197   0.483603 -0.2196    0.8273312    
L(IBO, 2)    0.287669   0.394106  0.7299    0.4697962    
L(IBO, 3)   -0.994678   0.382002 -2.6039    0.0129740 *  
IDE          0.125464   0.472280  0.2657    0.7919029    
L(IDE, 1)   -0.327985   0.605524 -0.5417    0.5911379    
L(IDE, 2)    1.407857   0.455512  3.0907    0.0036757 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ecarts-types robustes à l'hétéroscédasticité et l'autocorrélation à la Newey-West avec pré-mise en bruit blanc des résidus via un VAR à la Andrews &amp; Monahan (1992)</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>ardl_3132 <span class="sc">|&gt;</span> </span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coeftest</span>(<span class="at">vcov. =</span> sandwich<span class="sc">::</span>NeweyWest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
t test of coefficients:

             Estimate Std. Error t value      Pr(&gt;|t|)    
(Intercept)  2.620192   0.379766  6.8995 0.00000002945 ***
L(LRM, 1)    0.319208   0.079572  4.0116     0.0002646 ***
L(LRM, 2)    0.532606   0.107615  4.9492 0.00001470065 ***
L(LRM, 3)   -0.268666   0.115621 -2.3237     0.0254464 *  
LRY          0.672799   0.117126  5.7442 0.00000117359 ***
L(LRY, 1)   -0.257419   0.091166 -2.8236     0.0074408 ** 
IBO         -1.078518   0.222853 -4.8396 0.00002074949 ***
L(IBO, 1)   -0.106197   0.501467 -0.2118     0.8333869    
L(IBO, 2)    0.287669   0.318855  0.9022     0.3724929    
L(IBO, 3)   -0.994678   0.289926 -3.4308     0.0014366 ** 
IDE          0.125464   0.408967  0.3068     0.7606400    
L(IDE, 1)   -0.327985   0.542165 -0.6050     0.5487140    
L(IDE, 2)    1.407857   0.355976  3.9549     0.0003133 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<p>Savoir si et quel type de correction utiliser est un problème empirique dont la solution dépend du problème rencontré. Une bonne pratique peut cependant être de tester la robustesse de ses résultats avec différentes corrections afin de voir l’impact de chacune d’entre elle. Ici, il semblerait que les différentes corrections apportées ne changent pas les résultats de significativité de manière importante.</p>
<p>Rappel que nous ne savons pas encore si notre ARDL en niveau est valide comme nous n’avons pas encore testé s’il existe une relation entre les niveaux de nos variables.</p>
</section>
<section id="tester-la-présence-dune-relation-en-niveau" class="level3">
<h3 class="anchored" data-anchor-id="tester-la-présence-dune-relation-en-niveau">Tester la présence d’une relation en niveau</h3>
<p>Il semble que la capacité explicative de ce modèle soit très élevée. Cependant à ce stade on ne sait pas encore s’il existe une relation entre les variables en niveau. Pour cela on va estimer le modèle <span class="math inline">\(UECM\)</span> à partir du meilleur <span class="math inline">\(ARDL\)</span> en niveau (c’est à dire qu’on va choisir le même nombre de retards pour chaque variable en différence).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimer le modèle UECM à partir du meilleur ARDL en niveau trouvé</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>uecm_3132 <span class="ot">&lt;-</span> ARDL<span class="sc">::</span><span class="fu">uecm</span>(ardl_3132)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Afficher les résultats</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>uecm_3132 <span class="sc">|&gt;</span> </span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "zooreg" data:
Start = 1974 Q4, End = 1987 Q3

Call:
dynlm::dynlm(formula = full_formula, data = data, start = start, 
    end = end)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.029939 -0.008856 -0.002562  0.008190  0.072577 

Coefficients:
             Estimate Std. Error t value   Pr(&gt;|t|)    
(Intercept)   2.62019    0.56777   4.615 0.00004187 ***
L(LRM, 1)    -0.41685    0.09166  -4.548 0.00005154 ***
L(LRY, 1)     0.41538    0.11761   3.532    0.00108 ** 
L(IBO, 1)    -1.89172    0.39111  -4.837 0.00002093 ***
L(IDE, 1)     1.20534    0.44690   2.697    0.01028 *  
d(L(LRM, 1)) -0.26394    0.10192  -2.590    0.01343 *  
d(L(LRM, 2))  0.26867    0.10213   2.631    0.01214 *  
d(LRY)        0.67280    0.13116   5.129 0.00000832 ***
d(IBO)       -1.07852    0.32170  -3.353    0.00179 ** 
d(L(IBO, 1))  0.70701    0.46874   1.508    0.13953    
d(L(IBO, 2))  0.99468    0.39251   2.534    0.01540 *  
d(IDE)        0.12546    0.55445   0.226    0.82216    
d(L(IDE, 1)) -1.40786    0.55204  -2.550    0.01480 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0191 on 39 degrees of freedom
Multiple R-squared:  0.7458,    Adjusted R-squared:  0.6676 
F-statistic: 9.537 on 12 and 39 DF,  p-value: 0.00000003001</code></pre>
</div>
</div>
<p>Le modèle <span class="math inline">\(UECM\)</span> nous permet d’utiliser le Bound F-test de Pesaran et al (2001) qui va tester l’hypothèse nulle de non significativité conjointe des coefficients des variables en niveau. Pour cela on utilise la fonction <code>ARDl::bound_f_test()</code> qui va prendre comme argument, entre autre, un ARDL ou UECM (le modèle ARDL sera automatiquement transformé en UECM) et le “cas” indiquant si la constante et/ou la tendance doivent participer à l’équation de court- ou long-terme. Le paramètre <code>alpha</code> permet d’indiquer le niveau de significativité des valeurs critiques. En cas d’absence, seule la p.value est renvoyée.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bound F test dans lequel la constante participe dans l'équation de long-terme. </span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Valeurs critiques pour un niveau de significativité de 1%</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>res_f_test <span class="ot">&lt;-</span> </span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  ARDL<span class="sc">::</span><span class="fu">bounds_f_test</span>(</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    uecm_3132, <span class="co"># UECM</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">case =</span> <span class="dv">2</span>, <span class="co"># Constante dans l'équation de long-terme. Pas de tendance</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="fl">0.01</span> <span class="co"># Niveau de significativité de 1%</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Afficher le résultat et les valeurs critiques</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>res_f_test<span class="sc">$</span>tab</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>  statistic Lower-bound I(0) Upper-bound I(1) alpha     p.value
F  5.116768         3.674361         4.610394  0.01 0.004417563</code></pre>
</div>
</div>
<p>Si l’on considère la non-sphéricité des erreurs peut être un problème (ce qui ne semble pas être notre cas), on peut utiliser une matrice de variance-covariance des estimateurs robustes à ces problèmes avec le paramètre <code>vcov_matrix</code>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bound F-test avec la correction HAC de la matrice de variance-covariance des estimateurs</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">bounds_f_test</span>(</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  uecm_3132, <span class="co"># UECM</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">case =</span> <span class="dv">2</span>, <span class="co"># Constante dans l'équation de long-terme. Pas de tendance</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fl">0.01</span>, <span class="co"># Niveau de significativité de 1%</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">vcov_matrix   =</span> sandwich<span class="sc">::</span><span class="fu">vcovHAC</span>(uecm_3132) <span class="co"># Correction HAC</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>)[[<span class="st">"tab"</span>]]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>  statistic Lower-bound I(0) Upper-bound I(1) alpha  p.value
F  10.45075         3.674361         4.610394  0.01 0.000001</code></pre>
</div>
</div>
<p>Le Bound F-test sans correction de la matrice de variance-covariance nous donne l’intervalle suivant : <span class="math inline">\([3.67 ; 4.61]\)</span>. La valeur de la statistique calculée est <span class="math inline">\(5.12\)</span>. Cette statistique est supérieure à la valeur critique supérieure <span class="math inline">\(I(1)\)</span>. On rejette donc l’hypothèse nulle de non-significativité conjointe des coefficients en niveau au seuil de 1%. Il semblerait qu’il existe une relation de entre les niveaux des variables sélectionnées. La correction HAC ne change pas notre conclusion.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ne pas indiquer les valeurs critiques. </span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">bounds_f_test</span>(</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    uecm_3132, <span class="co"># UECM</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">case =</span> <span class="dv">2</span>, <span class="co"># Constante dans l'équation de long-terme. Pas de tendance</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Bounds F-test (Wald) for no cointegration

data:  d(LRM) ~ L(LRM, 1) + L(LRY, 1) + L(IBO, 1) + L(IDE, 1) + d(L(LRM,     1)) + d(L(LRM, 2)) + d(LRY) + d(IBO) + d(L(IBO, 1)) + d(L(IBO,     2)) + d(IDE) + d(L(IDE, 1))
F = 5.1168, p-value = 0.004418
alternative hypothesis: Possible cointegration
null values:
   k    T 
   3 1000 </code></pre>
</div>
</div>
<p>On va tester la significativité du coefficient de réversion à la moyenne (donné par le coefficient de la variable dépendante retardée en niveau) avec le Bound t-test de Pesaran et al (2001). Attention il ne faut pas regarder le test de Student classique cela est une erreur. Attention également, le Bound t-test n’est applicable que dans les cas 1, 3, 5…</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>res_t_test <span class="ot">&lt;-</span> </span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  ARDL<span class="sc">::</span><span class="fu">bounds_t_test</span>(</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    uecm_3132, </span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">case =</span> <span class="dv">3</span>, <span class="co"># La tendance passe dans l'équation de court-terme</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="fl">0.01</span> <span class="co"># Seuil de significativité à 1%</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>res_t_test<span class="sc">$</span>tab</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>  statistic Lower-bound I(0) Upper-bound I(1) alpha     p.value
t -4.547939        -3.442978        -4.379886  0.01 0.005538316</code></pre>
</div>
</div>
<p>On peut encore une fois appliquer une correction à la matrice de variance-covariance si nécessaire.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">bounds_t_test</span>(</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  uecm_3132, </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">case =</span> <span class="dv">3</span>, <span class="co"># La tendance passe dans l'équation de court-terme</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fl">0.01</span>, <span class="co"># Seuil de significativité à 1%</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">vcov_matrix   =</span> sandwich<span class="sc">::</span><span class="fu">vcovHAC</span>(uecm_3132) <span class="co"># Correction HAC</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>)[[<span class="st">"tab"</span>]]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>  statistic Lower-bound I(0) Upper-bound I(1) alpha      p.value
t -5.729028        -3.442978        -4.379886  0.01 0.0005510574</code></pre>
</div>
</div>
<p>L’intervalle en valeur absolue est donnée par : <span class="math inline">\([3.44;4.38]\)</span> . La statistique en valeur absolue est <span class="math inline">\(4.55\)</span>. Elle est supérieure à la borne supérieure <span class="math inline">\(I(1)\)</span>. On rejette donc l’hypothèse nulle de nullité de réversion à la moyenne. Il semblerait encore une fois qu’il existe une relation en niveau entre nos variables et que la correction HAC ne change pas nos résultats.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simplement afficher le résultat du test avec la p.value</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">bounds_t_test</span>(</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    uecm_3132, </span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">case =</span> <span class="dv">3</span>, <span class="co"># La tendance passe dans l'équation de court-terme</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Bounds t-test for no cointegration

data:  d(LRM) ~ L(LRM, 1) + L(LRY, 1) + L(IBO, 1) + L(IDE, 1) + d(L(LRM,     1)) + d(L(LRM, 2)) + d(LRY) + d(IBO) + d(L(IBO, 1)) + d(L(IBO,     2)) + d(IDE) + d(L(IDE, 1))
t = -4.5479, p-value = 0.005538
alternative hypothesis: Possible cointegration
null values:
   k    T 
   3 1000 </code></pre>
</div>
</div>
</section>
<section id="multiplicateurs" class="level3">
<h3 class="anchored" data-anchor-id="multiplicateurs">Multiplicateurs</h3>
<p>Au vu des tests qui sont concordants, il semblerait bien qu’il existe une relation entre les niveaux de nos variables bien quelles ne soient pas toutes intégrées du même ordre. On peut donc s’intéresser à l’interprétation des coefficients. Cependant, il peut être difficile de trouver l’interprétation à donner aux coefficients à cause de la dynamique du modèle et des nombreux retards inclus. Pour cela, on va calculer et interpréter les coefficients multiplicateurs de court- et long-terme avec la fonction <code>ARDL::multipliers()</code>. L’argument <code>type</code> permet d’indiquer le type de multiplicateur que l’on souhaite obtenir : “sr” pour le court-terme ; “lr” ou rien pour le long-terme ; un chiffre pour les multiplicateurs Delays et Interim.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Multiplicateurs de court-terme</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">multipliers</span>(</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>  ardl_3132, </span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"sr"</span> <span class="co"># Indiquer que l'on souhaite les multiplicateurs de court-terme</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Term   Estimate Std. Error    t value       Pr(&gt;|t|)
1 (Intercept)  2.6201916  0.5677679  4.6148990 0.000041868672
2         LRY  0.6727993  0.1311638  5.1294603 0.000008317401
3         IBO -1.0785180  0.3217011 -3.3525465 0.001790030300
4         IDE  0.1254643  0.5544522  0.2262852 0.822161398397</code></pre>
</div>
</div>
<p>Une augmentation temporaire d’1% (les variables sont en log) du revenu réel augmente l’offre de monnaie réelle de 0,67%. Cette augmentation est significativement différente de 0. L’augmentation du revenu réel conduit à d’avantage d’emprunt et un plus grand besoin de monnaie ce qui explique l’augmentation. Cependant, l’effet est inférieur à l’unité. L’offre de monnaie augmente moins fortement que l’augmentation du revenu.</p>
<p>A l’inverse lorsque les taux d’intérêts augmentent de manière temporaire de 1%, l’offre de monnaie réelle diminue de 1,07%. Une augmentation des taux rend les crédits plus onéreux et risqués ce qui diminue le nombre de crédits accordés et donc la création monétaire. Il semblerait que l’offre de monnaie et les taux d’intérêts évoluent de concert.</p>
<p>En revanche, les taux de dépôts bancaires n’ont pas l’air d’avoir un effet à court terme sur l’offre de monnaie réelle puisque le coefficient n’est pas significativement différent de 0.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Multiplicateurs de long-terme</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">multipliers</span>(ardl_3132) <span class="co"># Si aucun type n'est indiqué alors, il s'agit du long-terme</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Term   Estimate Std. Error   t value           Pr(&gt;|t|)
1 (Intercept)  6.2856579  0.7719160  8.142930 0.0000000006107445
2         LRY  0.9964676  0.1239310  8.040503 0.0000000008358472
3         IBO -4.5381160  0.5202961 -8.722180 0.0000000001058619
4         IDE  2.8915201  0.9950853  2.905801 0.0060092393605960</code></pre>
</div>
</div>
<p>Une augmentation permanente d’1% du revenu réel va entraîner une hausse de presque 1% de l’offre de monnaie réelle. L’effet est plus élevé que dans le court terme car la dynamique du modèle permet à l’augmentation de se distribuer dans le temps, augmentant ainsi l’effet final comparé à l’effet à l’impact. Il en va de même pour l’effet des taux d’intérêts qui font diminuer de 4,5% l’offre de monnaie réelle suite à une augmentation permanente de 1%. Il s’agit d’un effet extrêmement élevé. On peut expliquer cela par le fait que les taux d’intérêts ne sont généralement pas augmentés de manière permanente. Les augmentation (et donc l’écart à la valeur d’équilibre) sont généralement temporaires afin de limiter l’inflation.</p>
<p>Dans le long-terme, le taux de dépôt des banques devient significatif. On peut argumenter qu’il faut du temps pour que le taux de dépôt se traduise par une augmentation des dépôts et donc une plus forte création de monnaie.</p>
<p>On peut encore une fois corriger, si nécessaire, la matrice de variance-covariance des estimateurs en cas de problème de sphéricité des erreurs :</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">multipliers</span>(</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>  ardl_3132,</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">vcov_matrix   =</span> sandwich<span class="sc">::</span><span class="fu">vcovHAC</span>(ardl_3132)</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Term   Estimate Std. Error    t value                Pr(&gt;|t|)
1 (Intercept)  6.2856579  0.7468003   8.416786 0.000000000265435664888
2         LRY  0.9964676  0.1180266   8.442739 0.000000000245386410926
3         IBO -4.5381160  0.3606216 -12.584148 0.000000000000002612352
4         IDE  2.8915201  0.6488098   4.456653 0.000068344655203074774</code></pre>
</div>
</div>
<p>Si l’on s’intéresse à un effet dynamique et pas simplement à un impact immédiat, on peut regarder les multiplicateurs Delays qui indiquent la variation à une période <span class="math inline">\(t+S\)</span> suite à une variation temporaire en <span class="math inline">\(t\)</span>. Ici on va regarder jusqu’à <span class="math inline">\(t+15\)</span>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculer les multiplicateurs Delays jusqu'à 15 périodes</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">multipliers</span>(</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>  ardl_3132, </span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="dv">15</span>, <span class="co"># Nombre de Delays à calculer</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">se =</span> <span class="cn">TRUE</span> <span class="co"># Indiquer si l'on souhaite obtenir les écarts-types</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>  ARDL<span class="sc">::</span><span class="fu">plot_delay</span>(<span class="at">interval =</span> <span class="fl">0.95</span>) <span class="co"># Représenter graphiquement les impacts temporaires avec un intervalle de confiance de 95%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="04-ARDL-cointegration_files/figure-html/unnamed-chunk-36-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Notre argument concernant le temps nécessaire aux taux de dépôt bancaire pour faire effet semble se valider puisqu’on peut remarquer que l’effet d’une augmentation temporaire ne se manifeste qu’en <span class="math inline">\(t+2\)</span> puis <span class="math inline">\(t+4\)</span>. A l’inverse, on peut voir que l’effet d’une augmentation temporaire des taux d’intérêts va avoir un effet direct sur la quasi totalité des périodes, bien que celui-ci diminue. Rappel que IBO est une variable caractérisée par une variable unitaire. Les chocs qu’elle reçoit sont donc persistants ce qui peut expliquer cet effet persistant.</p>
</section>
<section id="relation-de-long-terme-et-vitesse-dajustement" class="level3">
<h3 class="anchored" data-anchor-id="relation-de-long-terme-et-vitesse-dajustement">Relation de long-terme et vitesse d’ajustement</h3>
<p>Il est possible à partir des multiplicateurs de long-terme de construire l’équation de cointégration. C’est à dire l’équation de long-terme, d’équilibre de l’offre de monnaie.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculer l'éuqation de cointégration (de long-terme de la variable LRM)</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>ce <span class="ot">&lt;-</span> </span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  ARDL<span class="sc">::</span><span class="fu">coint_eq</span>(</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    ardl_3132, <span class="co"># Modèle utiliser pour calculer l'équation de cointégration. Doit être un objet TS sinon ça devient bizarre</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">case =</span> <span class="dv">2</span> <span class="co"># Constante dans l'équation de long-terme et pas de tendance</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Représenter graphiquement la relation de cointégration contre les vraies valeurs de LRM</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>ARDL<span class="sc">::</span><span class="fu">plot_lr</span>(ardl_3132, <span class="at">coint_eq =</span> ce, <span class="at">show.legend =</span> <span class="cn">TRUE</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="04-ARDL-cointegration_files/figure-html/unnamed-chunk-37-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>On peut voir que sur les dernières années disponibles, l’offre de monnaie réelle a généralement été inférieure à son niveau de long-terme, impliquant des chocs lui faisant dévier de son équilibre. On peut retrouver la vitesse d’ajustement à ces chocs à partir du modèle <span class="math inline">\(UECM\)</span> ou <span class="math inline">\(RECM\)</span>. Ce dernier étant plus parcimonieux, les estimateurs devraient être légèrement plus précis.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimer le modèle RECM</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>recm_3132 <span class="ot">&lt;-</span> ARDL<span class="sc">::</span><span class="fu">recm</span>(uecm_3132, <span class="at">case =</span> <span class="dv">2</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(recm_3132)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Time series regression with "zooreg" data:
Start = 1974 Q4, End = 1987 Q3

Call:
dynlm::dynlm(formula = full_formula, data = data, start = start, 
    end = end)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.029939 -0.008856 -0.002562  0.008190  0.072577 

Coefficients:
             Estimate Std. Error t value    Pr(&gt;|t|)    
d(L(LRM, 1)) -0.26394    0.09008  -2.930    0.005405 ** 
d(L(LRM, 2))  0.26867    0.09127   2.944    0.005214 ** 
d(LRY)        0.67280    0.11591   5.805 0.000000703 ***
d(IBO)       -1.07852    0.30025  -3.592    0.000837 ***
d(L(IBO, 1))  0.70701    0.44359   1.594    0.118300    
d(L(IBO, 2))  0.99468    0.36491   2.726    0.009242 ** 
d(IDE)        0.12546    0.48290   0.260    0.796248    
d(L(IDE, 1)) -1.40786    0.48867  -2.881    0.006160 ** 
ect          -0.41685    0.07849  -5.311 0.000003633 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.01819 on 43 degrees of freedom
  (0 observation effacée parce que manquante)
Multiple R-squared:  0.7613,    Adjusted R-squared:  0.7113 
F-statistic: 15.24 on 9 and 43 DF,  p-value: 0.00000000009545</code></pre>
</div>
</div>
<p>La vitesse d’ajustement est donnée par le coefficient du terme <span class="math inline">\(ect\)</span>. Elle est ici de <span class="math inline">\(-0,41685\)</span> ce qui indiquerait un effet d’ajustement plutôt modéré. On peut calculer le temps que met l’offre de monnaie à revenir à sa situation d’équilibre suit à une variation : <span class="math inline">\(\frac{1}{0.41685} \approx 2.4\)</span>. Il faut environ 2.4 périodes de temps (donc deux trimestres et demi) pour que l’offre de monnaie revienne à son niveau d’équilibre suite à un écart.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>